#!/bin/ash
# this script based http://ipv4.web.fc2.com/map-e.html

SCRIPT_VERSION="2025.05.12-05-00"

# OpenWrt関数をロード
. /lib/functions.sh
. /lib/functions/network.sh
. /lib/netifd/netifd-proto.sh

# IPv6プレフィックスを取得
network_flush_cache
network_find_wan6 NET_IF6
network_get_ipaddr6 NET_ADDR6 "${NET_IF6}"
NEW_IP6_PREFIX=${NET_ADDR6}

# プレフィックスに対応するIPv4ベースアドレスを取得（prefix31用）
get_ruleprefix31_value() {
    local prefix="$1"

    case "$prefix" in
        "0x240b0010") echo "106,72" ;;
        "0x240b0012") echo "14,8" ;;
        "0x240b0250") echo "14,10" ;;
        "0x240b0252") echo "14,12" ;;
        "0x24047a80") echo "133,200" ;;
        "0x24047a84") echo "133,206" ;;
        *) echo "" ;;
    esac
}

# プレフィックスに対応するIPv4ベースアドレスを取得（prefix38用）
get_ruleprefix38_value() {
    local prefix="$1"

    case "$prefix" in
        "0x24047a8200") echo "125,196,208" ;;
        "0x24047a8204") echo "125,196,212" ;;
        "0x24047a8208") echo "125,198,140" ;;
        "0x24047a820c") echo "125,198,144" ;;
        "0x24047a8210") echo "125,198,212" ;;
        "0x24047a8214") echo "125,198,244" ;;
        "0x24047a8218") echo "122,131,104" ;;
        "0x24047a821c") echo "125,195,20" ;;
        "0x24047a8220") echo "133,203,160" ;;
        "0x24047a8224") echo "133,203,164" ;;
        "0x24047a8228") echo "133,203,168" ;;
        "0x24047a822c") echo "133,203,172" ;;
        "0x24047a8230") echo "133,203,176" ;;
        "0x24047a8234") echo "133,203,180" ;;
        "0x24047a8238") echo "133,203,184" ;;
        "0x24047a823c") echo "133,203,188" ;;
        "0x24047a8240") echo "133,209,0" ;;
        "0x24047a8244") echo "133,209,4" ;;
        "0x24047a8248") echo "133,209,8" ;;
        "0x24047a824c") echo "133,209,12" ;;
        "0x24047a8250") echo "133,209,16" ;;
        "0x24047a8254") echo "133,209,20" ;;
        "0x24047a8258") echo "133,209,24" ;;
        "0x24047a825c") echo "133,209,28" ;;
        "0x24047a8260") echo "133,204,192" ;;
        "0x24047a8264") echo "133,204,196" ;;
        "0x24047a8268") echo "133,204,200" ;;
        "0x24047a826c") echo "133,204,204" ;;
        "0x24047a8270") echo "133,204,208" ;;
        "0x24047a8274") echo "133,204,212" ;;
        "0x24047a8278") echo "133,204,216" ;;
        "0x24047a827c") echo "133,204,220" ;;
        "0x24047a8280") echo "133,203,224" ;;
        "0x24047a8284") echo "133,203,228" ;;
        "0x24047a8288") echo "133,203,232" ;;
        "0x24047a828c") echo "133,203,236" ;;
        "0x24047a8290") echo "133,203,240" ;;
        "0x24047a8294") echo "133,203,244" ;;
        "0x24047a8298") echo "133,203,248" ;;
        "0x24047a829c") echo "133,203,252" ;;
        "0x24047a82a0") echo "125,194,192" ;;
        "0x24047a82a4") echo "125,194,196" ;;
        "0x24047a82a8") echo "125,194,200" ;;
        "0x24047a82ac") echo "125,194,204" ;;
        "0x24047a82b0") echo "119,239,128" ;;
        "0x24047a82b4") echo "119,239,132" ;;
        "0x24047a82b8") echo "119,239,136" ;;
        "0x24047a82bc") echo "119,239,140" ;;
        "0x24047a82c0") echo "125,194,32" ;;
        "0x24047a82c4") echo "125,194,36" ;;
        "0x24047a82c8") echo "125,194,40" ;;
        "0x24047a82cc") echo "125,194,44" ;;
        "0x24047a82d0") echo "125,195,24" ;;
        "0x24047a82d4") echo "125,195,28" ;;
        "0x24047a82d8") echo "122,130,192" ;;
        "0x24047a82dc") echo "122,130,196" ;;
        "0x24047a82e0") echo "122,135,64" ;;
        "0x24047a82e4") echo "122,135,68" ;;
        "0x24047a82e8") echo "125,192,240" ;;
        "0x24047a82ec") echo "125,192,244" ;;
        "0x24047a82f0") echo "125,193,176" ;;
        "0x24047a82f4") echo "125,193,180" ;;
        "0x24047a82f8") echo "122,130,176" ;;
        "0x24047a82fc") echo "122,130,180" ;;
        "0x24047a8300") echo "122,131,24" ;;
        "0x24047a8304") echo "122,131,28" ;;
        "0x24047a8308") echo "122,131,32" ;;
        "0x24047a830c") echo "122,131,36" ;;
        "0x24047a8310") echo "119,243,112" ;;
        "0x24047a8314") echo "119,243,116" ;;
        "0x24047a8318") echo "219,107,136" ;;
        "0x24047a831c") echo "219,107,140" ;;
        "0x24047a8320") echo "220,144,224" ;;
        "0x24047a8324") echo "220,144,228" ;;
        "0x24047a8328") echo "125,194,64" ;;
        "0x24047a832c") echo "125,194,68" ;;
        "0x24047a8330") echo "221,171,40" ;;
        "0x24047a8334") echo "221,171,44" ;;
        "0x24047a8338") echo "110,233,80" ;;
        "0x24047a833c") echo "110,233,84" ;;
        "0x24047a8340") echo "119,241,184" ;;
        "0x24047a8344") echo "119,241,188" ;;
        "0x24047a8348") echo "119,243,56" ;;
        "0x24047a834c") echo "119,243,60" ;;
        "0x24047a8350") echo "125,199,8" ;;
        "0x24047a8354") echo "125,199,12" ;;
        "0x24047a8358") echo "125,196,96" ;;
        "0x24047a835c") echo "125,196,100" ;;
        "0x24047a8360") echo "122,130,104" ;;
        "0x24047a8364") echo "122,130,108" ;;
        "0x24047a8368") echo "122,130,112" ;;
        "0x24047a836c") echo "122,130,116" ;;
        "0x24047a8370") echo "49,129,152" ;;
        "0x24047a8374") echo "49,129,156" ;;
        "0x24047a8378") echo "49,129,192" ;;
        "0x24047a837c") echo "49,129,196" ;;
        "0x24047a8380") echo "49,129,120" ;;
        "0x24047a8384") echo "49,129,124" ;;
        "0x24047a8388") echo "221,170,40" ;;
        "0x24047a838c") echo "221,170,44" ;;
        "0x24047a8390") echo "60,239,108" ;;
        "0x24047a8394") echo "60,236,24" ;;
        "0x24047a8398") echo "122,130,120" ;;
        "0x24047a839c") echo "60,236,84" ;;
        "0x24047a83a0") echo "60,239,180" ;;
        "0x24047a83a4") echo "60,239,184" ;;
        "0x24047a83a8") echo "118,110,136" ;;
        "0x24047a83ac") echo "119,242,136" ;;
        "0x24047a83b0") echo "60,238,188" ;;
        "0x24047a83b4") echo "60,238,204" ;;
        "0x24047a83b8") echo "122,134,52" ;;
        "0x24047a83bc") echo "119,244,60" ;;
        "0x24047a83c0") echo "119,243,100" ;;
        "0x24047a83c4") echo "221,170,236" ;;
        "0x24047a83c8") echo "221,171,48" ;;
        "0x24047a83cc") echo "60,238,36" ;;
        "0x24047a83d0") echo "125,195,236" ;;
        "0x24047a83d4") echo "60,236,20" ;;
        "0x24047a83d8") echo "118,108,76" ;;
        "0x24047a83dc") echo "118,110,108" ;;
        "0x24047a83e0") echo "118,110,112" ;;
        "0x24047a83e4") echo "118,111,88" ;;
        "0x24047a83e8") echo "118,111,228" ;;
        "0x24047a83ec") echo "118,111,236" ;;
        "0x24047a83f0") echo "119,241,148" ;;
        "0x24047a83f4") echo "119,242,124" ;;
        "0x24047a83f8") echo "125,194,28" ;;
        "0x24047a83fc") echo "125,194,96" ;;
        "0x24047a8600") echo "133,204,128" ;;
        "0x24047a8604") echo "133,204,132" ;;
        "0x24047a8608") echo "133,204,136" ;;
        "0x24047a860c") echo "133,204,140" ;;
        "0x24047a8610") echo "133,204,144" ;;
        "0x24047a8614") echo "133,204,148" ;;
        "0x24047a8618") echo "133,204,152" ;;
        "0x24047a861c") echo "133,204,156" ;;
        "0x24047a8620") echo "133,204,160" ;;
        "0x24047a8624") echo "133,204,164" ;;
        "0x24047a8628") echo "133,204,168" ;;
        "0x24047a862c") echo "133,204,172" ;;
        "0x24047a8630") echo "133,204,176" ;;
        "0x24047a8634") echo "133,204,180" ;;
        "0x24047a8638") echo "133,204,184" ;;
        "0x24047a863c") echo "133,204,188" ;;
        "0x24047a8640") echo "133,203,192" ;;
        "0x24047a8644") echo "133,203,196" ;;
        "0x24047a8648") echo "133,203,200" ;;
        "0x24047a864c") echo "133,203,204" ;;
        "0x24047a8650") echo "133,203,208" ;;
        "0x24047a8654") echo "133,203,212" ;;
        "0x24047a8658") echo "133,203,216" ;;
        "0x24047a865c") echo "133,203,220" ;;
        "0x24047a8660") echo "133,204,0" ;;
        "0x24047a8664") echo "133,204,4" ;;
        "0x24047a8668") echo "133,204,8" ;;
        "0x24047a866c") echo "133,204,12" ;;
        "0x24047a8670") echo "133,204,16" ;;
        "0x24047a8674") echo "133,204,20" ;;
        "0x24047a8678") echo "133,204,24" ;;
        "0x24047a867c") echo "133,204,28" ;;
        "0x24047a8680") echo "133,204,64" ;;
        "0x24047a8684") echo "133,204,68" ;;
        "0x24047a8688") echo "133,204,72" ;;
        "0x24047a868c") echo "133,204,76" ;;
        "0x24047a8690") echo "133,204,80" ;;
        "0x24047a8694") echo "133,204,84" ;;
        "0x24047a8698") echo "133,204,88" ;;
        "0x24047a869c") echo "133,204,92" ;;
        "0x24047a86a0") echo "221,171,112" ;;
        "0x24047a86a4") echo "221,171,116" ;;
        "0x24047a86a8") echo "221,171,120" ;;
        "0x24047a86ac") echo "221,171,124" ;;
        "0x24047a86b0") echo "125,195,184" ;;
        "0x24047a86b4") echo "125,196,216" ;;
        "0x24047a86b8") echo "221,171,108" ;;
        "0x24047a86bc") echo "219,107,152" ;;
        "0x24047a86c0") echo "60,239,128" ;;
        "0x24047a86c4") echo "60,239,132" ;;
        "0x24047a86c8") echo "60,239,136" ;;
        "0x24047a86cc") echo "60,239,140" ;;
        "0x24047a86d0") echo "118,110,80" ;;
        "0x24047a86d4") echo "118,110,84" ;;
        "0x24047a86d8") echo "118,110,88" ;;
        "0x24047a86dc") echo "118,110,92" ;;
        "0x24047a86e0") echo "125,194,176" ;;
        "0x24047a86e4") echo "125,194,180" ;;
        "0x24047a86e8") echo "125,194,184" ;;
        "0x24047a86ec") echo "125,194,188" ;;
        "0x24047a86f0") echo "60,239,112" ;;
        "0x24047a86f4") echo "60,239,116" ;;
        "0x24047a86f8") echo "60,239,120" ;;
        "0x24047a86fc") echo "60,239,124" ;;
        "0x24047a8700") echo "125,195,56" ;;
        "0x24047a8704") echo "125,195,60" ;;
        "0x24047a8708") echo "125,196,32" ;;
        "0x24047a870c") echo "125,196,36" ;;
        "0x24047a8710") echo "118,108,80" ;;
        "0x24047a8714") echo "118,108,84" ;;
        "0x24047a8718") echo "118,111,80" ;;
        "0x24047a871c") echo "118,111,84" ;;
        "0x24047a8720") echo "218,227,176" ;;
        "0x24047a8724") echo "218,227,180" ;;
        "0x24047a8728") echo "60,239,208" ;;
        "0x24047a872c") echo "60,239,212" ;;
        "0x24047a8730") echo "118,109,56" ;;
        "0x24047a8734") echo "118,109,60" ;;
        "0x24047a8738") echo "122,131,88" ;;
        "0x24047a873c") echo "122,131,92" ;;
        "0x24047a8740") echo "122,131,96" ;;
        "0x24047a8744") echo "122,131,100" ;;
        "0x24047a8748") echo "122,130,48" ;;
        "0x24047a874c") echo "122,130,52" ;;
        "0x24047a8750") echo "125,198,224" ;;
        "0x24047a8754") echo "125,198,228" ;;
        "0x24047a8758") echo "119,243,104" ;;
        "0x24047a875c") echo "119,243,108" ;;
        "0x24047a8760") echo "118,109,152" ;;
        "0x24047a8764") echo "118,109,156" ;;
        "0x24047a8768") echo "118,111,104" ;;
        "0x24047a876c") echo "118,111,108" ;;
        "0x24047a8770") echo "119,239,48" ;;
        "0x24047a8774") echo "119,239,52" ;;
        "0x24047a8778") echo "122,130,16" ;;
        "0x24047a877c") echo "122,130,20" ;;
        "0x24047a8780") echo "125,196,128" ;;
        "0x24047a8784") echo "125,196,132" ;;
        "0x24047a8788") echo "122,131,48" ;;
        "0x24047a878c") echo "122,131,52" ;;
        "0x24047a8790") echo "122,134,104" ;;
        "0x24047a8794") echo "122,134,108" ;;
        "0x24047a8798") echo "60,238,208" ;;
        "0x24047a879c") echo "60,238,212" ;;
        "0x24047a87a0") echo "220,144,192" ;;
        "0x24047a87a4") echo "220,144,196" ;;
        "0x24047a87a8") echo "110,233,48" ;;
        "0x24047a87ac") echo "122,131,84" ;;
        "0x24047a87b0") echo "111,169,152" ;;
        "0x24047a87b4") echo "119,241,132" ;;
        "0x24047a87b8") echo "119,241,136" ;;
        "0x24047a87bc") echo "119,244,68" ;;
        "0x24047a87c0") echo "60,236,92" ;;
        "0x24047a87c4") echo "60,237,108" ;;
        "0x24047a87c8") echo "60,238,12" ;;
        "0x24047a87cc") echo "60,238,44" ;;
        "0x24047a87d0") echo "60,238,216" ;;
        "0x24047a87d4") echo "60,238,232" ;;
        "0x24047a87d8") echo "49,129,72" ;;
        "0x24047a87dc") echo "110,233,4" ;;
        "0x24047a87e0") echo "110,233,192" ;;
        "0x24047a87e4") echo "119,243,20" ;;
        "0x24047a87e8") echo "119,243,24" ;;
        "0x24047a87ec") echo "125,193,4" ;;
        "0x24047a87f0") echo "125,193,148" ;;
        "0x24047a87f4") echo "118,110,76" ;;
        "0x24047a87f8") echo "118,110,96" ;;
        "0x24047a87fc") echo "125,193,152" ;;
        *) echo "" ;;
    esac
}

# プレフィックスに対応するIPv4ベースアドレスを取得（prefix38_20用）
get_ruleprefix38_20_value() {
    local prefix="$1"

    case "$prefix" in
        "0x2400405000") echo "153,240,0" ;;
        "0x2400405004") echo "153,240,16" ;;
        "0x2400405008") echo "153,240,32" ;;
        "0x240040500c") echo "153,240,48" ;;
        "0x2400405010") echo "153,240,64" ;;
        "0x2400405014") echo "153,240,80" ;;
        "0x2400405018") echo "153,240,96" ;;
        "0x240040501c") echo "153,240,112" ;;
        "0x2400405020") echo "153,240,128" ;;
        "0x2400405024") echo "153,240,144" ;;
        "0x2400405028") echo "153,240,160" ;;
        "0x240040502c") echo "153,240,176" ;;
        "0x2400405030") echo "153,240,192" ;;
        "0x2400405034") echo "153,240,208" ;;
        "0x2400405038") echo "153,240,224" ;;
        "0x240040503c") echo "153,240,240" ;;
        "0x2400405040") echo "153,241,0" ;;
        "0x2400405044") echo "153,241,16" ;;
        "0x2400405048") echo "153,241,32" ;;
        "0x240040504c") echo "153,241,48" ;;
        "0x2400405050") echo "153,241,64" ;;
        "0x2400405054") echo "153,241,80" ;;
        "0x2400405058") echo "153,241,96" ;;
        "0x240040505c") echo "153,241,112" ;;
        "0x2400405060") echo "153,241,128" ;;
        "0x2400405064") echo "153,241,144" ;;
        "0x2400405068") echo "153,241,160" ;;
        "0x240040506c") echo "153,241,176" ;;
        "0x2400405070") echo "153,241,192" ;;
        "0x2400405074") echo "153,241,208" ;;
        "0x2400405078") echo "153,241,224" ;;
        "0x240040507c") echo "153,241,240" ;;
        "0x2400405080") echo "153,242,0" ;;
        "0x2400405084") echo "153,242,16" ;;
        "0x2400405088") echo "153,242,32" ;;
        "0x240040508c") echo "153,242,48" ;;
        "0x2400405090") echo "153,242,64" ;;
        "0x2400405094") echo "153,242,80" ;;
        "0x2400405098") echo "153,242,96" ;;
        "0x240040509c") echo "153,242,112" ;;
        "0x24004050a0") echo "153,242,128" ;;
        "0x24004050a4") echo "153,242,144" ;;
        "0x24004050a8") echo "153,242,160" ;;
        "0x24004050ac") echo "153,242,176" ;;
        "0x24004050b0") echo "153,242,192" ;;
        "0x24004050b4") echo "153,242,208" ;;
        "0x24004050b8") echo "153,242,224" ;;
        "0x24004050bc") echo "153,242,240" ;;
        "0x24004050c0") echo "153,243,0" ;;
        "0x24004050c4") echo "153,243,16" ;;
        "0x24004050c8") echo "153,243,32" ;;
        "0x24004050cc") echo "153,243,48" ;;
        "0x24004050d0") echo "153,243,64" ;;
        "0x24004050d4") echo "153,243,80" ;;
        "0x24004050d8") echo "153,243,96" ;;
        "0x24004050dc") echo "153,243,112" ;;
        "0x24004050e0") echo "153,243,128" ;;
        "0x24004050e4") echo "153,243,144" ;;
        "0x24004050e8") echo "153,243,160" ;;
        "0x24004050ec") echo "153,243,176" ;;
        "0x24004050f0") echo "153,243,192" ;;
        "0x24004050f4") echo "153,243,208" ;;
        "0x24004050f8") echo "153,243,224" ;;
        "0x24004050fc") echo "153,243,240" ;;
        "0x2400405100") echo "122,26,0" ;;
        "0x2400405104") echo "122,26,16" ;;
        "0x2400405108") echo "122,26,32" ;;
        "0x240040510c") echo "122,26,48" ;;
        "0x2400405110") echo "122,26,64" ;;
        "0x2400405114") echo "122,26,80" ;;
        "0x2400405118") echo "122,26,96" ;;
        "0x240040511c") echo "122,26,112" ;;
        "0x2400405120") echo "114,146,64" ;;
        "0x2400405124") echo "114,146,80" ;;
        "0x2400405128") echo "114,146,96" ;;
        "0x240040512c") echo "114,146,112" ;;
        "0x2400405130") echo "114,148,192" ;;
        "0x2400405134") echo "114,148,208" ;;
        "0x2400405138") echo "114,148,224" ;;
        "0x240040513c") echo "114,148,240" ;;
        "0x2400405140") echo "114,150,192" ;;
        "0x2400405144") echo "114,150,208" ;;
        "0x2400405148") echo "114,150,224" ;;
        "0x240040514c") echo "114,150,240" ;;
        "0x2400405150") echo "114,163,64" ;;
        "0x2400405154") echo "114,163,80" ;;
        "0x2400405158") echo "114,163,96" ;;
        "0x240040515c") echo "114,163,112" ;;
        "0x2400405180") echo "114,172,192" ;;
        "0x2400405184") echo "114,172,208" ;;
        "0x2400405188") echo "114,172,224" ;;
        "0x240040518c") echo "114,172,240" ;;
        "0x2400405190") echo "114,177,64" ;;
        "0x2400405194") echo "114,177,80" ;;
        "0x2400405198") echo "114,177,96" ;;
        "0x240040519c") echo "114,177,112" ;;
        "0x24004051a0") echo "118,0,64" ;;
        "0x24004051a4") echo "118,0,80" ;;
        "0x24004051a8") echo "118,0,96" ;;
        "0x24004051ac") echo "118,0,112" ;;
        "0x24004051b0") echo "118,7,64" ;;
        "0x24004051b4") echo "118,7,80" ;;
        "0x24004051b8") echo "118,7,96" ;;
        "0x24004051bc") echo "118,7,112" ;;
        "0x2400405200") echo "123,225,192" ;;
        "0x2400405204") echo "123,225,208" ;;
        "0x2400405208") echo "123,225,224" ;;
        "0x240040520c") echo "123,225,240" ;;
        "0x2400405210") echo "153,134,0" ;;
        "0x2400405214") echo "153,134,16" ;;
        "0x2400405218") echo "153,134,32" ;;
        "0x240040521c") echo "153,134,48" ;;
        "0x2400405220") echo "153,139,128" ;;
        "0x2400405224") echo "153,139,144" ;;
        "0x2400405228") echo "153,139,160" ;;
        "0x240040522c") echo "153,139,176" ;;
        "0x2400405230") echo "153,151,64" ;;
        "0x2400405234") echo "153,151,80" ;;
        "0x2400405238") echo "153,151,96" ;;
        "0x240040523c") echo "153,151,112" ;;
        "0x24004051c0") echo "118,8,192" ;;
        "0x24004051c4") echo "118,8,208" ;;
        "0x24004051c8") echo "118,8,224" ;;
        "0x24004051cc") echo "118,8,240" ;;
        "0x24004051d0") echo "118,9,0" ;;
        "0x24004051d4") echo "118,9,16" ;;
        "0x24004051d8") echo "118,9,32" ;;
        "0x24004051dc") echo "118,9,48" ;;
        "0x24004051e0") echo "123,218,64" ;;
        "0x24004051e4") echo "123,218,80" ;;
        "0x24004051e8") echo "123,218,96" ;;
        "0x24004051ec") echo "123,218,112" ;;
        "0x24004051f0") echo "123,220,128" ;;
        "0x24004051f4") echo "123,220,144" ;;
        "0x24004051f8") echo "123,220,160" ;;
        "0x24004051fc") echo "123,220,176" ;;
        "0x2400405240") echo "153,170,64" ;;
        "0x2400405244") echo "153,170,80" ;;
        "0x2400405248") echo "153,170,96" ;;
        "0x240040524c") echo "153,170,112" ;;
        "0x2400405250") echo "153,170,192" ;;
        "0x2400405254") echo "153,170,208" ;;
        "0x2400405258") echo "153,170,224" ;;
        "0x240040525c") echo "153,170,240" ;;
        "0x2400405260") echo "61,127,128" ;;
        "0x2400405264") echo "61,127,144" ;;
        "0x2400405268") echo "114,146,0" ;;
        "0x240040526c") echo "114,146,16" ;;
        "0x2400405270") echo "114,146,128" ;;
        "0x2400405274") echo "114,146,144" ;;
        "0x2400405278") echo "114,148,64" ;;
        "0x240040527c") echo "114,148,80" ;;
        "0x2400405280") echo "114,148,160" ;;
        "0x2400405284") echo "114,148,176" ;;
        "0x2400405288") echo "114,149,0" ;;
        "0x240040528c") echo "114,149,16" ;;
        "0x2400405290") echo "114,150,160" ;;
        "0x2400405294") echo "114,150,176" ;;
        "0x2400405298") echo "114,158,0" ;;
        "0x240040529c") echo "114,158,16" ;;
        "0x2400405160") echo "114,163,128" ;;
        "0x2400405164") echo "114,163,144" ;;
        "0x2400405168") echo "114,163,160" ;;
        "0x240040516c") echo "114,163,176" ;;
        "0x2400405170") echo "114,167,64" ;;
        "0x2400405174") echo "114,167,80" ;;
        "0x2400405178") echo "114,167,96" ;;
        "0x240040517c") echo "114,167,112" ;;
        "0x2400405300") echo "114,162,128" ;;
        "0x2400405304") echo "114,162,144" ;;
        "0x2400405308") echo "114,163,0" ;;
        "0x240040530c") echo "114,163,16" ;;
        "0x2400405310") echo "114,165,224" ;;
        "0x2400405314") echo "114,165,240" ;;
        "0x2400405318") echo "114,167,192" ;;
        "0x240040531c") echo "114,167,208" ;;
        "0x2400405320") echo "114,177,128" ;;
        "0x2400405324") echo "114,177,144" ;;
        "0x2400405328") echo "114,178,224" ;;
        "0x240040532c") echo "114,178,240" ;;
        "0x2400405330") echo "118,1,0" ;;
        "0x2400405334") echo "118,1,16" ;;
        "0x2400405338") echo "118,3,192" ;;
        "0x240040533c") echo "118,3,208" ;;
        "0x2400405340") echo "118,6,64" ;;
        "0x2400405344") echo "118,6,80" ;;
        "0x2400405348") echo "118,7,160" ;;
        "0x240040534c") echo "118,7,176" ;;
        "0x2400405360") echo "118,9,128" ;;
        "0x2400405364") echo "118,9,144" ;;
        "0x2400405368") echo "118,22,128" ;;
        "0x240040536c") echo "118,22,144" ;;
        "0x2400405370") echo "122,16,0" ;;
        "0x2400405374") echo "122,16,16" ;;
        "0x2400405378") echo "123,220,0" ;;
        "0x240040537c") echo "123,220,16" ;;
        "0x2400405350") echo "118,7,192" ;;
        "0x2400405354") echo "118,7,208" ;;
        "0x2400405358") echo "118,9,64" ;;
        "0x240040535c") echo "118,9,80" ;;
        "0x2400405380") echo "153,173,0" ;;
        "0x2400405384") echo "153,173,16" ;;
        "0x2400405388") echo "153,173,32" ;;
        "0x240040538c") echo "153,173,48" ;;
        "0x2400405390") echo "153,173,64" ;;
        "0x2400405394") echo "153,173,80" ;;
        "0x2400405398") echo "153,173,96" ;;
        "0x240040539c") echo "153,173,112" ;;
        "0x24004053a0") echo "153,173,128" ;;
        "0x24004053a4") echo "153,173,144" ;;
        "0x24004053a8") echo "153,173,160" ;;
        "0x24004053ac") echo "153,173,176" ;;
        "0x24004053b0") echo "153,173,192" ;;
        "0x24004053b4") echo "153,173,208" ;;
        "0x24004053b8") echo "153,173,224" ;;
        "0x24004053bc") echo "153,173,240" ;;
        "0x24004053c0") echo "153,238,0" ;;
        "0x24004053c4") echo "153,238,16" ;;
        "0x24004053c8") echo "153,238,32" ;;
        "0x24004053cc") echo "153,238,48" ;;
        "0x24004053d0") echo "153,238,64" ;;
        "0x24004053d4") echo "153,238,80" ;;
        "0x24004053d8") echo "153,238,96" ;;
        "0x24004053dc") echo "153,238,112" ;;
        "0x24004053e0") echo "153,238,128" ;;
        "0x24004053e4") echo "153,238,144" ;;
        "0x24004053e8") echo "153,238,160" ;;
        "0x24004053ec") echo "153,238,176" ;;
        "0x24004053f0") echo "153,238,192" ;;
        "0x24004053f4") echo "153,238,208" ;;
        "0x24004053f8") echo "153,238,224" ;;
        "0x24004053fc") echo "153,238,240" ;;
        "0x2400415000") echo "153,239,0" ;;
        "0x2400415004") echo "153,239,16" ;;
        "0x2400415008") echo "153,239,32" ;;
        "0x240041500c") echo "153,239,48" ;;
        "0x2400415010") echo "153,239,64" ;;
        "0x2400415014") echo "153,239,80" ;;
        "0x2400415018") echo "153,239,96" ;;
        "0x240041501c") echo "153,239,112" ;;
        "0x2400415020") echo "153,239,128" ;;
        "0x2400415024") echo "153,239,144" ;;
        "0x2400415028") echo "153,239,160" ;;
        "0x240041502c") echo "153,239,176" ;;
        "0x2400415030") echo "153,239,192" ;;
        "0x2400415034") echo "153,239,208" ;;
        "0x2400415038") echo "153,239,224" ;;
        "0x240041503c") echo "153,239,240" ;;
        "0x2400415040") echo "153,252,0" ;;
        "0x2400415044") echo "153,252,16" ;;
        "0x2400415048") echo "153,252,32" ;;
        "0x240041504c") echo "153,252,48" ;;
        "0x2400415050") echo "153,252,64" ;;
        "0x2400415054") echo "153,252,80" ;;
        "0x2400415058") echo "153,252,96" ;;
        "0x240041505c") echo "153,252,112" ;;
        "0x2400415060") echo "153,252,128" ;;
        "0x2400415064") echo "153,252,144" ;;
        "0x2400415068") echo "153,252,160" ;;
        "0x240041506c") echo "153,252,176" ;;
        "0x2400415070") echo "153,252,192" ;;
        "0x2400415074") echo "153,252,208" ;;
        "0x2400415078") echo "153,252,224" ;;
        "0x240041507c") echo "153,252,240" ;;
        "0x2400415080") echo "123,222,96" ;;
        "0x2400415084") echo "123,222,112" ;;
        "0x2400415088") echo "123,225,96" ;;
        "0x240041508c") echo "123,225,112" ;;
        "0x2400415090") echo "123,225,160" ;;
        "0x2400415094") echo "123,225,176" ;;
        "0x2400415098") echo "124,84,96" ;;
        "0x240041509c") echo "124,84,112" ;;
        "0x2400415380") echo "180,12,128" ;;
        "0x2400415384") echo "180,12,144" ;;
        "0x2400415388") echo "180,26,96" ;;
        "0x240041538c") echo "180,26,112" ;;
        "0x2400415390") echo "180,26,160" ;;
        "0x2400415394") echo "180,26,176" ;;
        "0x2400415398") echo "180,26,224" ;;
        "0x240041539c") echo "180,26,240" ;;
        "0x24004153a0") echo "180,30,0" ;;
        "0x24004153a4") echo "180,30,16" ;;
        "0x24004153a8") echo "180,31,96" ;;
        "0x24004153ac") echo "180,31,112" ;;
        "0x24004153c0") echo "180,46,0" ;;
        "0x24004153c4") echo "180,46,16" ;;
        "0x24004153c8") echo "180,48,0" ;;
        "0x24004153cc") echo "180,48,16" ;;
        "0x24004153d0") echo "180,50,192" ;;
        "0x24004153d4") echo "180,50,208" ;;
        "0x24004153d8") echo "180,53,0" ;;
        "0x24004153dc") echo "180,53,16" ;;
        "0x24004153b0") echo "180,32,64" ;;
        "0x24004153b4") echo "180,32,80" ;;
        "0x24004153b8") echo "180,34,160" ;;
        "0x24004153bc") echo "180,34,176" ;;
        "0x24004153e0") echo "218,230,128" ;;
        "0x24004153e4") echo "218,230,144" ;;
        "0x24004153e8") echo "219,161,64" ;;
        "0x24004153ec") echo "219,161,80" ;;
        "0x24004153f0") echo "220,96,64" ;;
        "0x24004153f4") echo "220,96,80" ;;
        "0x24004153f8") echo "220,99,0" ;;
        "0x24004153fc") echo "220,99,16" ;;
        "0x2400415100") echo "180,60,0" ;;
        "0x2400415104") echo "180,60,16" ;;
        "0x2400415108") echo "180,60,32" ;;
        "0x240041510c") echo "180,60,48" ;;
        "0x2400415110") echo "180,60,64" ;;
        "0x2400415114") echo "180,60,80" ;;
        "0x2400415118") echo "180,60,96" ;;
        "0x240041511c") echo "180,60,112" ;;
        "0x2400415120") echo "180,60,128" ;;
        "0x2400415124") echo "180,60,144" ;;
        "0x2400415128") echo "180,60,160" ;;
        "0x240041512c") echo "180,60,176" ;;
        "0x2400415130") echo "180,60,192" ;;
        "0x2400415134") echo "180,60,208" ;;
        "0x2400415138") echo "180,60,224" ;;
        "0x240041513c") echo "180,60,240" ;;
        "0x2400415140") echo "153,139,0" ;;
        "0x2400415144") echo "153,139,16" ;;
        "0x2400415148") echo "153,139,32" ;;
        "0x240041514c") echo "153,139,48" ;;
        "0x2400415150") echo "153,139,64" ;;
        "0x2400415154") echo "153,139,80" ;;
        "0x2400415158") echo "153,139,96" ;;
        "0x240041515c") echo "153,139,112" ;;
        "0x2400415160") echo "219,161,128" ;;
        "0x2400415164") echo "219,161,144" ;;
        "0x2400415168") echo "219,161,160" ;;
        "0x240041516c") echo "219,161,176" ;;
        "0x2400415170") echo "219,161,192" ;;
        "0x2400415174") echo "219,161,208" ;;
        "0x2400415178") echo "219,161,224" ;;
        "0x240041517c") echo "219,161,240" ;;
        "0x24004151c0") echo "124,84,128" ;;
        "0x24004151c4") echo "124,84,144" ;;
        "0x24004151c8") echo "124,98,192" ;;
        "0x24004151cc") echo "124,98,208" ;;
        "0x2400415180") echo "153,187,0" ;;
        "0x2400415184") echo "153,187,16" ;;
        "0x2400415188") echo "153,187,32" ;;
        "0x240041518c") echo "153,187,48" ;;
        "0x2400415190") echo "153,191,0" ;;
        "0x2400415194") echo "153,191,16" ;;
        "0x2400415198") echo "153,191,32" ;;
        "0x240041519c") echo "153,191,48" ;;
        "0x24004151a0") echo "180,12,64" ;;
        "0x24004151a4") echo "180,12,80" ;;
        "0x24004151a8") echo "180,12,96" ;;
        "0x24004151ac") echo "180,12,112" ;;
        "0x24004151b0") echo "180,13,0" ;;
        "0x24004151b4") echo "180,13,16" ;;
        "0x24004151b8") echo "180,13,32" ;;
        "0x24004151bc") echo "180,13,48" ;;
        "0x24004151d0") echo "124,100,0" ;;
        "0x24004151d4") echo "124,100,16" ;;
        "0x24004151d8") echo "124,100,224" ;;
        "0x24004151dc") echo "124,100,240" ;;
        "0x2400415300") echo "153,165,96" ;;
        "0x2400415304") echo "153,165,112" ;;
        "0x2400415308") echo "153,165,160" ;;
        "0x240041530c") echo "153,165,176" ;;
        "0x2400415310") echo "153,171,224" ;;
        "0x2400415314") echo "153,171,240" ;;
        "0x2400415318") echo "153,175,0" ;;
        "0x240041531c") echo "153,175,16" ;;
        "0x2400415344") echo "220,106,48" ;;
        "0x2400415374") echo "220,106,80" ;;
        "0x2400415340") echo "220,106,32" ;;
        "0x2400415370") echo "220,106,64" ;;
        "0x2400415320") echo "153,181,0" ;;
        "0x2400415324") echo "153,181,16" ;;
        "0x2400415328") echo "153,183,224" ;;
        "0x240041532c") echo "153,183,240" ;;
        "0x2400415330") echo "153,184,128" ;;
        "0x2400415334") echo "153,184,144" ;;
        "0x2400415338") echo "153,187,224" ;;
        "0x240041533c") echo "153,187,240" ;;
        "0x2400415360") echo "153,191,192" ;;
        "0x2400415364") echo "153,191,208" ;;
        "0x2400415348") echo "153,188,0" ;;
        "0x240041534c") echo "153,188,16" ;;
        "0x2400415350") echo "153,190,128" ;;
        "0x2400415354") echo "153,190,144" ;;
        "0x2400415358") echo "153,191,64" ;;
        "0x240041535c") echo "153,191,80" ;;
        "0x2400415368") echo "153,194,96" ;;
        "0x240041536c") echo "153,194,112" ;;
        "0x2400415200") echo "180,16,0" ;;
        "0x2400415204") echo "180,16,16" ;;
        "0x2400415208") echo "180,16,32" ;;
        "0x240041520c") echo "180,16,48" ;;
        "0x2400415210") echo "180,29,128" ;;
        "0x2400415214") echo "180,29,144" ;;
        "0x2400415218") echo "180,29,160" ;;
        "0x240041521c") echo "180,29,176" ;;
        "0x2400415220") echo "180,59,64" ;;
        "0x2400415224") echo "180,59,80" ;;
        "0x2400415228") echo "180,59,96" ;;
        "0x240041522c") echo "180,59,112" ;;
        "0x2400415230") echo "219,161,0" ;;
        "0x2400415234") echo "219,161,16" ;;
        "0x2400415238") echo "219,161,32" ;;
        "0x240041523c") echo "219,161,48" ;;
        "0x2400415250") echo "153,131,96" ;;
        "0x2400415254") echo "153,131,112" ;;
        "0x2400415260") echo "153,131,128" ;;
        "0x2400415264") echo "153,131,144" ;;
        "0x2400415268") echo "153,132,128" ;;
        "0x240041526c") echo "153,132,144" ;;
        "0x2400415240") echo "153,129,160" ;;
        "0x2400415244") echo "153,129,176" ;;
        "0x2400415248") echo "153,130,0" ;;
        "0x240041524c") echo "153,130,16" ;;
        "0x2400415270") echo "153,134,64" ;;
        "0x2400415274") echo "153,134,80" ;;
        "0x2400415278") echo "153,137,0" ;;
        "0x240041527c") echo "153,137,16" ;;
        "0x2400415280") echo "153,139,192" ;;
        "0x2400415284") echo "153,139,208" ;;
        "0x2400415288") echo "153,151,32" ;;
        "0x240041528c") echo "153,151,48" ;;
        "0x2400415290") echo "153,156,96" ;;
        "0x2400415294") echo "153,156,112" ;;
        "0x2400415298") echo "153,156,128" ;;
        "0x240041529c") echo "153,156,144" ;;
        *) echo "" ;;
    esac
}

OK_mape_mold() {

    # IPv6プレフィックス取得 (追加: 取得失敗チェック)
    network_flush_cache
    network_find_wan6 NET_IF6
    network_get_ipaddr6 NET_ADDR6 "${NET_IF6}"
    NEW_IP6_PREFIX=${NET_ADDR6}

    # Check if IPv6 prefix was obtained
    if [ -z "$NEW_IP6_PREFIX" ]; then
        printf "%s\n" "$(color red "$(get_message "MSG_MAPE_IPV6_PREFIX_FAILED")")" # Assuming color/get_message exist
        return 1
    fi

    debug_log "DEBUG" "IPv6 prefix obtained: $NEW_IP6_PREFIX"
    
    # --- BEGIN IPv6 HEXTET Parsing Correction (POSIX awk compliant, space output) ---
    local ipv6_addr="$NEW_IP6_PREFIX"
    local h0_str h1_str h2_str h3_str # Shell variables to hold hex strings

    # Use awk for robust :: expansion and extraction of first 4 hextets (POSIX compliant)
    local awk_output
    awk_output=$(echo "$ipv6_addr" | awk '
    BEGIN { FS=":"; OFS=":" } # Keep OFS=":" for sub(), but print explicitly spaced
    {
        num_fields = NF
        if ($0 ~ /::/) {
            zero_fields = 8 - num_fields + 1
            zeros = ""
            for (i = 1; i <= zero_fields; i++) {
                zeros = zeros "0" (i < zero_fields ? ":" : "")
            }
            sub(/::/, zeros)
            if ($1 == "") $1 = "0"
            # Need to recalculate NF after sub for trailing :: check
            if ($NF == "" && NF == 8) $NF = "0"
            if (NF == 1 && $1 == "") $1 = "0"
        }

        # Extract first 4 fields, defaulting to "0" if empty (POSIX awk compliant)
        h0 = $1; if (h0 == "") h0 = "0"
        h1 = $2; if (h1 == "") h1 = "0"
        h2 = $3; if (h2 == "") h2 = "0"
        h3 = $4; if (h3 == "") h3 = "0"

        # Print the first 4 hex strings, explicitly space-separated
        print h0 " " h1 " " h2 " " h3
    }')

    # Read the space-separated hex strings output by awk into shell variables
    read -r h0_str h1_str h2_str h3_str <<EOF
$awk_output
EOF

    # Check if awk produced valid output (at least one value)
    if [ -z "$h0_str" ]; then
        printf "%s\n" "$(color red "Error: Failed to parse IPv6 prefix using awk.")" # Assuming color exists
        return 1
    fi

    # Convert hex strings to decimal numbers (HEXTET0-HEXTET3)
    local HEXTET0 HEXTET1 HEXTET2 HEXTET3
    HEXTET0=$(printf %d "0x${h0_str:-0}")
    HEXTET1=$(printf %d "0x${h1_str:-0}")
    HEXTET2=$(printf %d "0x${h2_str:-0}")
    HEXTET3=$(printf %d "0x${h3_str:-0}")
    
    # --- END IPv6 HEXTET Parsing Correction ---

    # 各種計算 (複雑なネスト計算を分割) 
    local PREFIX31 PREFIX38
    local h0_mul=$(( HEXTET0 * 65536 ))    # 0x10000
    local h1_masked=$(( HEXTET1 & 65534 )) # 0xfffe
    PREFIX31=$(( h0_mul + h1_masked ))

    local h0_mul2=$(( HEXTET0 * 16777216 )) # 0x1000000
    local h1_mul=$(( HEXTET1 * 256 ))      # 0x100
    local h2_masked=$(( HEXTET2 & 64512 )) # 0xfc00
    local h2_shift=$(( h2_masked >> 8 ))
    PREFIX38=$(( h0_mul2 + h1_mul + h2_shift ))

    # グローバル変数として設定するパラメータの初期化
    OFFSET=6  # デフォルト値
    RFC=false # デフォルト値
    IP6PREFIXLEN=""
    PSIDLEN=""
    IPV4=""
    PSID=0
    PORTS=""
    EALEN=""
    IP4PREFIXLEN=""
    IP6PFX=""
    BR=""
    CE=""

    # プレフィックス値に対応するデータを取得
    local prefix31_hex
    prefix31_hex=$(printf 0x%x "$PREFIX31")
    local prefix38_hex
    prefix38_hex=$(printf 0x%x "$PREFIX38")

    # IPv4アドレスと各種パラメータの決定
    local octet1 octet2 octet3 octet4 octet
    if [ -n "$(get_ruleprefix38_value "$prefix38_hex")" ]; then
        octet="$(get_ruleprefix38_value "$prefix38_hex")"
        debug_log "DEBUG" "Matched ruleprefix38: $octet"
        IFS=',' read -r octet1 octet2 octet3 <<EOF
$octet
EOF
        local temp1=$(( HEXTET2 & 768 ))    # 0x0300
        local temp2=$(( temp1 >> 8 ))
        octet3=$(( octet3 | temp2 ))
        octet4=$(( HEXTET2 & 255 ))         # 0x00ff

        IPADDR="${octet1}.${octet2}.${octet3}.${octet4}"
        IPV4="${octet1}.${octet2}.0.0"
        IP6PREFIXLEN=38
        PSIDLEN=8
        OFFSET=4
    elif [ -n "$(get_ruleprefix31_value "$prefix31_hex")" ]; then
        octet="$(get_ruleprefix31_value "$prefix31_hex")"
        debug_log "DEBUG" "Matched ruleprefix31: $octet"
        IFS=',' read -r octet1 octet2 <<EOF
$octet
EOF
        octet2=$(( octet2 | (HEXTET1 & 1) )) # 0x0001
        local temp1=$(( HEXTET2 & 65280 ))  # 0xff00
        octet3=$(( temp1 >> 8 ))
        octet4=$(( HEXTET2 & 255 ))         # 0x00ff

        IPADDR="${octet1}.${octet2}.${octet3}.${octet4}"
        IPV4="${octet1}.${octet2}.0.0"
        IP6PREFIXLEN=31
        PSIDLEN=8
        OFFSET=4
    elif [ -n "$(get_ruleprefix38_20_value "$prefix38_hex")" ]; then
        octet="$(get_ruleprefix38_20_value "$prefix38_hex")"
        debug_log "DEBUG" "Matched ruleprefix38_20: $octet"
        IFS=',' read -r octet1 octet2 octet3 <<EOF
$octet
EOF
        local temp1=$(( HEXTET2 & 960 ))    # 0x03c0
        local temp2=$(( temp1 >> 6 ))
        octet3=$(( octet3 | temp2 ))
        local temp3=$(( HEXTET2 & 63 ))     # 0x003f
        local temp4=$(( temp3 << 2 ))
        local temp5=$(( HEXTET3 & 49152 ))  # 0xc000
        local temp6=$(( temp5 >> 14 ))
        octet4=$(( temp4 | temp6 ))

        IPADDR="${octet1}.${octet2}.${octet3}.${octet4}"
        IPV4="${octet1}.${octet2}.0.0"
        IP6PREFIXLEN=38
        PSIDLEN=6
        OFFSET=6 # ruleprefix38_20では offset=6 を使用
    else
        printf "%s\n" "$(color red "Error: Unsupported IPv6 prefix.")" # Assuming color exists
        debug_log "DEBUG" "No matching ruleprefix found for prefix31=$prefix31_hex or prefix38=$prefix38_hex in mape_mold()"
        return 1
    fi

    # PSID計算
    if [ "$PSIDLEN" -eq 8 ]; then
        PSID=$(( (HEXTET3 & 65280) >> 8 )) # 0xff00
        debug_log "DEBUG" "PSID calculation for PSIDLEN=8: $PSID"
    elif [ "$PSIDLEN" -eq 6 ]; then
        PSID=$(( (HEXTET3 & 16128) >> 8 )) # 0x3f00
        debug_log "DEBUG" "PSID calculation for PSIDLEN=6: $PSID"
    else
        PSID=0 # フォールバック
        debug_log "DEBUG" "PSIDLEN ($PSIDLEN) is not 8 or 6, PSID set to 0"
    fi

    # ポート範囲の計算
    PORTS=""
    local AMAX=$(( (1 << OFFSET) - 1 ))
    debug_log "DEBUG" "Calculating port ranges: AMAX=$AMAX, OFFSET=$OFFSET, PSIDLEN=$PSIDLEN, PSID=$PSID"

    local A
    for A in $(seq 1 "$AMAX"); do
        local shift_bits=$(( 16 - OFFSET ))
        local port_base=$(( A << shift_bits ))
        local psid_shift=$(( 16 - OFFSET - PSIDLEN ))
        if [ "$psid_shift" -lt 0 ]; then
            debug_log "DEBUG" "Invalid calculation: psid_shift is negative ($psid_shift). Check OFFSET and PSIDLEN."
            psid_shift=0
        fi
        local psid_part=$(( PSID << psid_shift ))
        local port=$(( port_base | psid_part ))
        local port_range_size=$(( 1 << psid_shift ))
        if [ "$port_range_size" -le 0 ]; then
             debug_log "DEBUG" "Invalid calculation: port_range_size is not positive ($port_range_size)."
             port_range_size=1
        fi
        local port_end=$(( port + port_range_size - 1 ))

        PORTS="${PORTS}${port}-${port_end}"

        if [ "$A" -lt "$AMAX" ]; then
            if [ $(( A % 3 )) -eq 0 ]; then
                PORTS="${PORTS}\\n"
            else
                PORTS="${PORTS} "
            fi
        fi
    done

    # CEアドレス計算用のHEXTETを準備
    local CE_HEXTET0 CE_HEXTET1 CE_HEXTET2 CE_HEXTET3 CE_HEXTET4 CE_HEXTET5 CE_HEXTET6 CE_HEXTET7
    CE_HEXTET0=$HEXTET0
    CE_HEXTET1=$HEXTET1
    CE_HEXTET2=$HEXTET2
    CE_HEXTET3=$(( HEXTET3 & 65280 )) # 上位バイトのみ保持 (0xff00)

    # CEアドレス計算ロジック (RFCフラグはfalse固定)
    if [ "$RFC" = "true" ]; then
        # このブロックはRFC=falseのため通常実行されない
        debug_log "DEBUG" "Calculating CE Address (RFC mode - unexpected)"
        CE_HEXTET4=0
        CE_HEXTET5=$(( (octet1 << 8) | octet2 ))
        CE_HEXTET6=$(( (octet3 << 8) | octet4 ))
        CE_HEXTET7=$PSID
    else
        debug_log "DEBUG" "Calculating CE Address (Non-RFC mode)"
        CE_HEXTET4=$octet1
        CE_HEXTET5=$(( (octet2 << 8) | octet3 ))
        CE_HEXTET6=$(( octet4 << 8 ))
        CE_HEXTET7=$(( PSID << 8 ))
    fi

    # CEアドレス文字列の生成
    local CE0 CE1 CE2 CE3 CE4 CE5 CE6 CE7
    CE0=$(printf %04x "$CE_HEXTET0")
    CE1=$(printf %04x "$CE_HEXTET1")
    CE2=$(printf %04x "$CE_HEXTET2")
    CE3=$(printf %04x "$CE_HEXTET3")
    CE4=$(printf %04x "$CE_HEXTET4")
    CE5=$(printf %04x "$CE_HEXTET5")
    CE6=$(printf %04x "$CE_HEXTET6")
    CE7=$(printf %04x "$CE_HEXTET7")
    CE="${CE0}:${CE1}:${CE2}:${CE3}:${CE4}:${CE5}:${CE6}:${CE7}"
    debug_log "DEBUG" "Generated CE address (CE): $CE"

    # EALENとプレフィックス長の計算
    EALEN=$(( 56 - IP6PREFIXLEN ))
    IP4PREFIXLEN=$(( 32 - (EALEN - PSIDLEN) ))
    debug_log "DEBUG" "EALEN=$EALEN, IP4PREFIXLEN=$IP4PREFIXLEN"

    # IPv6プレフィックスの計算
    local IP6PFX0 IP6PFX1 IP6PFX2
    if [ "$IP6PREFIXLEN" -eq 38 ]; then
        local hextet2_2=$(( HEXTET2 & 64512 ))  # 0xfc00
        IP6PFX0=$(printf %x "$HEXTET0")
        IP6PFX1=$(printf %x "$HEXTET1")
        IP6PFX2=$(printf %x "$hextet2_2")
        IP6PFX="${IP6PFX0}:${IP6PFX1}:${IP6PFX2}"
    elif [ "$IP6PREFIXLEN" -eq 31 ]; then
        local hextet2_1=$(( HEXTET1 & 65534 ))  # 0xfffe
        IP6PFX0=$(printf %x "$HEXTET0")
        IP6PFX1=$(printf %x "$hextet2_1")
        IP6PFX="${IP6PFX0}:${IP6PFX1}"
    else
        IP6PFX="" # フォールバック
        debug_log "WARNING" "Could not determine IP6PFX for IP6PREFIXLEN=$IP6PREFIXLEN"
    fi
    debug_log "DEBUG" "Generated IPv6 prefix (IP6PFX): $IP6PFX"

    # ブロードバンドルーターアドレス(BR/Peer)の判定
    BR=""
    # ruleprefix31 にマッチした場合のBR判定 (IP6PREFIXLENが31であることを確認)
    if [ "$IP6PREFIXLEN" -eq 31 ]; then
        if [ "$PREFIX31" -ge 604240512 ] && [ "$PREFIX31" -lt 604240516 ]; then # 0x24047a80 - 0x24047a83
            BR="2001:260:700:1::1:275"
        elif [ "$PREFIX31" -ge 604240516 ] && [ "$PREFIX31" -lt 604240520 ]; then # 0x24047a84 - 0x24047a87
            BR="2001:260:700:1::1:276"
        elif { [ "$PREFIX31" -ge 604512272 ] && [ "$PREFIX31" -lt 604512276 ]; } || \
             { [ "$PREFIX31" -ge 604512848 ] && [ "$PREFIX31" -lt 604512852 ]; }; then # 0x240b0010-0x240b0013 or 0x240b0250-0x240b0253
            BR="2404:9200:225:100::64"
        fi
    fi
    # 上記でBRが設定されなかった場合、ruleprefix38_20 にマッチした場合のBRを設定
    # (IP6PREFIXLEN=38, PSIDLEN=6, OFFSET=6 は ruleprefix38_20 の特徴)
    if [ -z "$BR" ] && [ "$IP6PREFIXLEN" -eq 38 ] && [ "$PSIDLEN" -eq 6 ] && [ "$OFFSET" -eq 6 ]; then
        # この条件は ruleprefix38_20 にマッチしたことを示す。
        # get_ruleprefix38_20_value の結果が空でないことを確認する。
        if [ -n "$(get_ruleprefix38_20_value "$prefix38_hex")" ]; then
             BR="2001:380:a120::9"
        fi
    fi
    debug_log "DEBUG" "Selected peer address (BR): $BR"

    debug_log "DEBUG" "Exiting mape_mold() function successfully"
    return 0
}

mape_mold() {
    # グローバル変数としてNEW_IP6_PREFIXをここで定義
    local NET_IF6 NET_ADDR6
    network_flush_cache
    network_find_wan6 NET_IF6
    network_get_ipaddr6 NET_ADDR6 "${NET_IF6}"
    NEW_IP6_PREFIX=${NET_ADDR6}


    # Check if IPv6 prefix was obtained
    if [ -z "$NEW_IP6_PREFIX" ]; then
        printf "%s\n" "$(color red "$(get_message "MSG_MAPE_IPV6_PREFIX_FAILED")")" # Assuming color/get_message exist
        return 1
    fi

    debug_log "DEBUG" "IPv6 prefix obtained: $NEW_IP6_PREFIX"
    
    # --- BEGIN IPv6 HEXTET Parsing Correction (POSIX awk compliant, space output) ---
    local ipv6_addr="$NEW_IP6_PREFIX"
    local h0_str h1_str h2_str h3_str # Shell variables to hold hex strings

    # Use awk for robust :: expansion and extraction of first 4 hextets (POSIX compliant)
    local awk_output
    awk_output=$(echo "$ipv6_addr" | awk '
    BEGIN { FS=":"; OFS=":" } # Keep OFS=":" for sub(), but print explicitly spaced
    {
        num_fields = NF
        if ($0 ~ /::/) {
            zero_fields = 8 - num_fields + 1
            zeros = ""
            for (i = 1; i <= zero_fields; i++) {
                zeros = zeros "0" (i < zero_fields ? ":" : "")
            }
            sub(/::/, zeros)
            if ($1 == "") $1 = "0"
            # Need to recalculate NF after sub for trailing :: check
            if ($NF == "" && NF == 8) $NF = "0"
            if (NF == 1 && $1 == "") $1 = "0"
        }

        # Extract first 4 fields, defaulting to "0" if empty (POSIX awk compliant)
        h0 = $1; if (h0 == "") h0 = "0"
        h1 = $2; if (h1 == "") h1 = "0"
        h2 = $3; if (h2 == "") h2 = "0"
        h3 = $4; if (h3 == "") h3 = "0"

        # Print the first 4 hex strings, explicitly space-separated
        print h0 " " h1 " " h2 " " h3
    }')

    # Read the space-separated hex strings output by awk into shell variables
    read -r h0_str h1_str h2_str h3_str <<EOF
$awk_output
EOF

    # Check if awk produced valid output (at least one value)
    if [ -z "$h0_str" ]; then
        printf "%s\n" "$(color red "Error: Failed to parse IPv6 prefix using awk.")" # Assuming color exists
        return 1
    fi

    # Convert hex strings to decimal numbers (HEXTET0-HEXTET3)
    local HEXTET0 HEXTET1 HEXTET2 HEXTET3
    HEXTET0=$(printf %d "0x${h0_str:-0}")
    HEXTET1=$(printf %d "0x${h1_str:-0}")
    HEXTET2=$(printf %d "0x${h2_str:-0}")
    HEXTET3=$(printf %d "0x${h3_str:-0}")
    
    # --- END IPv6 HEXTET Parsing Correction ---

    # 各種計算 (複雑なネスト計算を分割) 
    local PREFIX31 PREFIX38
    local h0_mul=$(( HEXTET0 * 65536 ))    # 0x10000
    local h1_masked=$(( HEXTET1 & 65534 )) # 0xfffe
    PREFIX31=$(( h0_mul + h1_masked ))

    local h0_mul2=$(( HEXTET0 * 16777216 )) # 0x1000000
    local h1_mul=$(( HEXTET1 * 256 ))      # 0x100
    local h2_masked=$(( HEXTET2 & 64512 )) # 0xfc00
    local h2_shift=$(( h2_masked >> 8 ))
    PREFIX38=$(( h0_mul2 + h1_mul + h2_shift ))

    # グローバル変数として設定するパラメータの初期化
    OFFSET=6  # デフォルト値
    RFC=false # デフォルト値
    IP6PREFIXLEN=""
    PSIDLEN=""
    IPADDR="" # フルIPv4アドレス用
    IPV4=""   # 設定用IPv4アドレス (*.*.0.0形式)
    PSID=0
    PORTS=""
    EALEN=""
    IP4PREFIXLEN=""
    IP6PFX=""
    BR=""
    CE=""
    IPV6PREFIX=""
    
    # プレフィックス値に対応するデータを取得
    local prefix31_hex
    prefix31_hex=$(printf 0x%x "$PREFIX31")
    local prefix38_hex
    prefix38_hex=$(printf 0x%x "$PREFIX38")

    # IPv4アドレスと各種パラメータの決定
    local octet1 octet2 octet3 octet4 octet
    if [ -n "$(get_ruleprefix38_value "$prefix38_hex")" ]; then
        octet="$(get_ruleprefix38_value "$prefix38_hex")"
        debug_log "DEBUG" "Matched ruleprefix38: $octet"
        IFS=',' read -r octet1 octet2 octet3 <<EOF
$octet
EOF
        local temp1=$(( HEXTET2 & 768 ))    # 0x0300
        local temp2=$(( temp1 >> 8 ))
        octet3=$(( octet3 | temp2 ))
        octet4=$(( HEXTET2 & 255 ))         # 0x00ff

        IPADDR="${octet1}.${octet2}.${octet3}.${octet4}" # フルアドレス
        IPV4="${octet1}.${octet2}.0.0"                 # 設定用アドレス (*.*.0.0)
        IP6PREFIXLEN=38
        PSIDLEN=8
        OFFSET=4
    elif [ -n "$(get_ruleprefix31_value "$prefix31_hex")" ]; then
        octet="$(get_ruleprefix31_value "$prefix31_hex")"
        debug_log "DEBUG" "Matched ruleprefix31: $octet"
        IFS=',' read -r octet1 octet2 <<EOF
$octet
EOF
        octet2=$(( octet2 | (HEXTET1 & 1) )) # 0x0001
        local temp1=$(( HEXTET2 & 65280 ))  # 0xff00
        octet3=$(( temp1 >> 8 ))
        octet4=$(( HEXTET2 & 255 ))         # 0x00ff

        IPADDR="${octet1}.${octet2}.${octet3}.${octet4}" # フルアドレス
        IPV4="${octet1}.${octet2}.0.0"                 # 設定用アドレス (*.*.0.0)
        IP6PREFIXLEN=31
        PSIDLEN=8
        OFFSET=4
    elif [ -n "$(get_ruleprefix38_20_value "$prefix38_hex")" ]; then
        octet="$(get_ruleprefix38_20_value "$prefix38_hex")"
        debug_log "DEBUG" "Matched ruleprefix38_20: $octet"
        IFS=',' read -r octet1 octet2 octet3 <<EOF
$octet
EOF
        local temp1=$(( HEXTET2 & 960 ))    # 0x03c0
        local temp2=$(( temp1 >> 6 ))
        octet3=$(( octet3 | temp2 ))
        local temp3=$(( HEXTET2 & 63 ))     # 0x003f
        local temp4=$(( temp3 << 2 ))
        local temp5=$(( HEXTET3 & 49152 ))  # 0xc000
        local temp6=$(( temp5 >> 14 ))
        octet4=$(( temp4 | temp6 ))

        IPADDR="${octet1}.${octet2}.${octet3}.${octet4}" # フルアドレス
        IPV4="${octet1}.${octet2}.0.0"                 # 設定用アドレス (*.*.0.0)
        IP6PREFIXLEN=38
        PSIDLEN=6
        OFFSET=6 # ruleprefix38_20では offset=6 を使用
    else
        printf "%s\n" "$(color red "Error: Unsupported IPv6 prefix.")" # Assuming color exists
        debug_log "DEBUG" "No matching ruleprefix found for prefix31=$prefix31_hex or prefix38=$prefix38_hex in mape_mold()"
        return 1
    fi

    # PSID計算
    if [ "$PSIDLEN" -eq 8 ]; then
        PSID=$(( (HEXTET3 & 65280) >> 8 )) # 0xff00
        debug_log "DEBUG" "PSID calculation for PSIDLEN=8: $PSID"
    elif [ "$PSIDLEN" -eq 6 ]; then
        PSID=$(( (HEXTET3 & 16128) >> 8 )) # 0x3f00
        debug_log "DEBUG" "PSID calculation for PSIDLEN=6: $PSID"
    else
        PSID=0 # フォールバック
        debug_log "DEBUG" "PSIDLEN ($PSIDLEN) is not 8 or 6, PSID set to 0"
    fi

    # ポート範囲の計算
    PORTS=""
    local AMAX=$(( (1 << OFFSET) - 1 ))
    debug_log "DEBUG" "Calculating port ranges: AMAX=$AMAX, OFFSET=$OFFSET, PSIDLEN=$PSIDLEN, PSID=$PSID"

    local A
    for A in $(seq 1 "$AMAX"); do
        local shift_bits=$(( 16 - OFFSET ))
        local port_base=$(( A << shift_bits ))
        local psid_shift=$(( 16 - OFFSET - PSIDLEN ))
        if [ "$psid_shift" -lt 0 ]; then
            debug_log "DEBUG" "Invalid calculation: psid_shift is negative ($psid_shift). Check OFFSET and PSIDLEN."
            psid_shift=0
        fi
        local psid_part=$(( PSID << psid_shift ))
        local port=$(( port_base | psid_part ))
        local port_range_size=$(( 1 << psid_shift ))
        if [ "$port_range_size" -le 0 ]; then
             debug_log "DEBUG" "Invalid calculation: port_range_size is not positive ($port_range_size)."
             port_range_size=1
        fi
        local port_end=$(( port + port_range_size - 1 ))

        PORTS="${PORTS}${port}-${port_end}"

        if [ "$A" -lt "$AMAX" ]; then
            if [ $(( A % 3 )) -eq 0 ]; then
                PORTS="${PORTS}\\n"
            else
                PORTS="${PORTS} "
            fi
        fi
    done

    # CEアドレス計算用のHEXTETを準備
    local CE_HEXTET0 CE_HEXTET1 CE_HEXTET2 CE_HEXTET3 CE_HEXTET4 CE_HEXTET5 CE_HEXTET6 CE_HEXTET7
    CE_HEXTET0=$HEXTET0
    CE_HEXTET1=$HEXTET1
    CE_HEXTET2=$HEXTET2
    CE_HEXTET3=$(( HEXTET3 & 65280 )) # 上位バイトのみ保持 (0xff00)

    # CEアドレス計算ロジック (RFCフラグはfalse固定)
    local ce_octet1 ce_octet2 ce_octet3 ce_octet4
    # IPADDR は既に計算済みなので、ここからパースする
    # 注意: この octet変数は、上記のIPv4アドレス決定ロジックのローカル変数とは別物として扱う
    ce_octet1=$(echo "$IPADDR" | cut -d. -f1)
    ce_octet2=$(echo "$IPADDR" | cut -d. -f2)
    ce_octet3=$(echo "$IPADDR" | cut -d. -f3)
    ce_octet4=$(echo "$IPADDR" | cut -d. -f4)
    
    if [ "$RFC" = "true" ]; then
        # このブロックはRFC=falseのため通常実行されない
        debug_log "DEBUG" "Calculating CE Address (RFC mode - unexpected)"
        CE_HEXTET4=0
        CE_HEXTET5=$(( (ce_octet1 << 8) | ce_octet2 ))
        CE_HEXTET6=$(( (ce_octet3 << 8) | ce_octet4 ))
        CE_HEXTET7=$PSID
    else
        debug_log "DEBUG" "Calculating CE Address (Non-RFC mode)"
        CE_HEXTET4=$ce_octet1
        CE_HEXTET5=$(( (ce_octet2 << 8) | ce_octet3 ))
        CE_HEXTET6=$(( ce_octet4 << 8 ))
        CE_HEXTET7=$(( PSID << 8 ))
    fi

    # CEアドレス文字列の生成
    local CE0 CE1 CE2 CE3 CE4 CE5 CE6 CE7
    CE0=$(printf %04x "$CE_HEXTET0")
    CE1=$(printf %04x "$CE_HEXTET1")
    CE2=$(printf %04x "$CE_HEXTET2")
    CE3=$(printf %04x "$CE_HEXTET3")
    CE4=$(printf %04x "$CE_HEXTET4")
    CE5=$(printf %04x "$CE_HEXTET5")
    CE6=$(printf %04x "$CE_HEXTET6")
    CE7=$(printf %04x "$CE_HEXTET7")
    CE="${CE0}:${CE1}:${CE2}:${CE3}:${CE4}:${CE5}:${CE6}:${CE7}"
    IPV6PREFIX="${h0_str}:${h1_str}:${h2_str}:${h3_str}::"
    debug_log "DEBUG" "Generated CE address (CE): $CE"
    debug_log "DEBUG" "Generated CE Network Prefix for wan6 (IPV6PREFIX): $IPV6PREFIX"

    # EALENとプレフィックス長の計算
    EALEN=$(( 56 - IP6PREFIXLEN ))
    IP4PREFIXLEN=$(( 32 - (EALEN - PSIDLEN) ))
    debug_log "DEBUG" "EALEN=$EALEN, IP4PREFIXLEN=$IP4PREFIXLEN"

    # IPv6プレフィックスの計算
    local IP6PFX0 IP6PFX1 IP6PFX2
    if [ "$IP6PREFIXLEN" -eq 38 ]; then
        local hextet2_2=$(( HEXTET2 & 64512 ))  # 0xfc00
        IP6PFX0=$(printf %x "$HEXTET0")
        IP6PFX1=$(printf %x "$HEXTET1")
        IP6PFX2=$(printf %x "$hextet2_2")
        IP6PFX="${IP6PFX0}:${IP6PFX1}:${IP6PFX2}"
    elif [ "$IP6PREFIXLEN" -eq 31 ]; then
        local hextet2_1=$(( HEXTET1 & 65534 ))  # 0xfffe
        IP6PFX0=$(printf %x "$HEXTET0")
        IP6PFX1=$(printf %x "$hextet2_1")
        IP6PFX="${IP6PFX0}:${IP6PFX1}"
    else
        IP6PFX="" # フォールバック
        debug_log "WARNING" "Could not determine IP6PFX for IP6PREFIXLEN=$IP6PREFIXLEN"
    fi
    debug_log "DEBUG" "Generated IPv6 prefix (IP6PFX): $IP6PFX"

    # ブロードバンドルーターアドレス(BR/Peer)の判定
    BR=""
    # ruleprefix31 にマッチした場合のBR判定 (IP6PREFIXLENが31であることを確認)
    if [ "$IP6PREFIXLEN" -eq 31 ]; then
        if [ "$PREFIX31" -ge 604240512 ] && [ "$PREFIX31" -lt 604240516 ]; then # 0x24047a80 - 0x24047a83
            BR="2001:260:700:1::1:275"
        elif [ "$PREFIX31" -ge 604240516 ] && [ "$PREFIX31" -lt 604240520 ]; then # 0x24047a84 - 0x24047a87
            BR="2001:260:700:1::1:276"
        elif { [ "$PREFIX31" -ge 604512272 ] && [ "$PREFIX31" -lt 604512276 ]; } || \
             { [ "$PREFIX31" -ge 604512848 ] && [ "$PREFIX31" -lt 604512852 ]; }; then # 0x240b0010-0x240b0013 or 0x240b0250-0x240b0253
            BR="2404:9200:225:100::64"
        fi
    fi
    # 上記でBRが設定されなかった場合、ruleprefix38_20 にマッチした場合のBRを設定
    # (IP6PREFIXLEN=38, PSIDLEN=6, OFFSET=6 は ruleprefix38_20 の特徴)
    if [ -z "$BR" ] && [ "$IP6PREFIXLEN" -eq 38 ] && [ "$PSIDLEN" -eq 6 ] && [ "$OFFSET" -eq 6 ]; then
        # この条件は ruleprefix38_20 にマッチしたことを示す。
        # JavaScriptでは ruleprefix38_20[prefix38] が真であれば BR を設定するため、
        # get_ruleprefix38_20_value の結果が空でないことを確認する。
        if [ -n "$(get_ruleprefix38_20_value "$prefix38_hex")" ]; then
             BR="2001:380:a120::9"
        fi
    fi
    debug_log "DEBUG" "Selected peer address (BR): $BR"

    debug_log "DEBUG" "Exiting mape_mold() function successfully"
    return 0
}

# MAP-E設定を適用する関数
NG_mape_config() {
    local WANMAP='wanmap' # 設定セクション名
    local wan_firewall_zone_name='wan'
    local osversion_file="${CACHE_DIR}/osversion.ch"
    local osversion=""
    
    # 設定のバックアップ作成
    debug_log "DEBUG" "Backing up configuration files..."
    cp /etc/config/network /etc/config/network.map-e.bak && debug_log "DEBUG" "network backup created." || debug_log "DEBUG" "Failed to backup network config."
    cp /etc/config/dhcp /etc/config/dhcp.map-e.bak && debug_log "DEBUG" "dhcp backup created." || debug_log "DEBUG" "Failed to backup dhcp config."
    cp /etc/config/firewall /etc/config/firewall.map-e.bak && debug_log "DEBUG" "firewall backup created." || debug_log "DEBUG" "Failed to backup firewall config."

    debug_log "DEBUG" "Applying MAP-E configuration using UCI (strictly adhering to user-defined versioning rules)"

    # --- COMMON - 全バージョン共通設定のみ) ---

    # 既存のwanインターフェースの自動起動を停止
    uci set network.wan.auto='0'

    # --- DHCP LAN 設定 ---
    uci set dhcp.lan.dhcpv6='server'
    uci set dhcp.lan.ra='server'
    uci set dhcp.lan.ndp='disabled'
    uci set dhcp.lan.force='1'
    uci set dhcp.lan.ra_slaac='1'
    uci delete dhcp.lan.ra_flags
    uci add_list dhcp.lan.ra_flags='managed-config'
    uci add_list dhcp.lan.ra_flags='other-config'
    uci -q delete dhcp.lan.ra_management
    uci -q delete dhcp.lan.ra_default

    # --- DHCP WAN6 設定 ---
    uci set dhcp.wan6=dhcp
    uci set dhcp.wan6.master='1'
    uci set dhcp.wan6.ra='relay'
    uci set dhcp.wan6.dhcpv6='relay'
    uci set dhcp.wan6.ndp='relay'

    # --- WAN6 インターフェース設定 ---
    uci set network.wan6.proto='dhcpv6'
    uci set network.wan6.reqaddress='try'
    uci set network.wan6.reqprefix='auto'
    uci set network.wan6.ip6prefix="${CE}::/64"

    # --- WANMAP (MAP-E) インターフェース設定 ---
    uci set network.${WANMAP}=interface
    uci set network.${WANMAP}.proto='map'
    uci set network.${WANMAP}.maptype='map-e'
    uci set network.${WANMAP}.peeraddr="${BR}"
    uci set network.${WANMAP}.ipaddr="${IPV4}"
    uci set network.${WANMAP}.ip4prefixlen="${IP4PREFIXLEN}"
    uci set network.${WANMAP}.ip6prefix="${IP6PFX}::"
    uci set network.${WANMAP}.ip6prefixlen="${IP6PREFIXLEN}"
    uci set network.${WANMAP}.ealen="${EALEN}"
    uci set network.${WANMAP}.psidlen="${PSIDLEN}"
    uci set network.${WANMAP}.offset="${OFFSET}"
    uci set network.${WANMAP}.mtu='1460'
    uci set network.${WANMAP}.encaplimit='ignore'

    # 1. OSバージョン取得
    if [ -f "$osversion_file" ]; then
        osversion=$(cat "$osversion_file")
        debug_log "DEBUG" "OS Version read from cache: $osversion"
    fi

    # --- バージョン固有設定 ---
    if echo "$osversion" | grep -q "^19"; then
        debug_log "DEBUG" "Applying settings for OpenWrt 19.x compatible version"
        # 19系の場合:
        uci -q delete network.${WANMAP}.tunlink 
        uci add_list network.${WANMAP}.tunlink='wan6'
    else
        # 19系以外 (または osversion.ch が存在しない/空の場合)
        debug_log "DEBUG" "Applying settings for OpenWrt non-19.x version or undefined version"
        uci set dhcp.wan6.interface='wan6'
        uci set dhcp.wan6.ignore='1'
        uci set network.${WANMAP}.legacymap='1'
        uci set network.${WANMAP}.tunlink='wan6' 
    fi
    
    # --- ファイアウォール設定 (動的ゾーン検索) ---
    local wan_zone_uci_path
    wan_zone_uci_path=$(uci show firewall | awk -F'[.=]' -v z_name="${wan_firewall_zone_name}" '
        $1 == "firewall" && $3 == "name" && $4 == "\047"z_name"\047" {
            print $1"."$2; # firewall.@zone[x] を出力
            exit;
        }
    ')
    
    if [ -n "$wan_zone_uci_path" ]; then
        debug_log "DEBUG" "Found firewall zone '${wan_firewall_zone_name}' at UCI path ${wan_zone_uci_path}"
        
        # 'wan' インターフェースをゾーンから削除
        uci del_list "${wan_zone_uci_path}.network=wan"
        debug_log "DEBUG" "Attempted to remove 'wan' from ${wan_zone_uci_path}.network"

        # '${WANMAP}' インターフェースをゾーンに追加
        uci add_list "${wan_zone_uci_path}.network=${WANMAP}"
        debug_log "DEBUG" "Attempted to add '${WANMAP}' to ${wan_zone_uci_path}.network"

        # masq='1', mtu_fix='1' を設定
        uci set "${wan_zone_uci_path}.masq='1'"
        uci set "${wan_zone_uci_path}.mtu_fix='1'"
        debug_log "DEBUG" "Set masq=1 and mtu_fix=1 for zone ${wan_zone_uci_path}"

    else
        debug_log "DEBUG" "Firewall zone named '${wan_firewall_zone_name}' not found. Firewall rule for MAP-E may need manual configuration."
    fi

    # 設定の保存
    debug_log "DEBUG" "Committing UCI changes..."
    local commit_ok=1
    if ! uci commit network; then debug_log "ERROR" "Failed to commit network."; commit_ok=0; fi
    if ! uci commit dhcp; then debug_log "ERROR" "Failed to commit dhcp."; commit_ok=0; fi
    if ! uci commit firewall; then debug_log "ERROR" "Failed to commit firewall."; commit_ok=0; fi

    if [ "$commit_ok" -eq 1 ]; then
        debug_log "DEBUG" "All UCI sections committed successfully."
    else
        debug_log "ERROR" "One or more UCI sections failed to commit."
    fi

    return 0
}

# prompt_wan6_prefix_configuration_method (仮の関数名)
#
# Prompts the user to determine how the wan6 IPv6 prefix should be configured,
# specifically whether 'network.wan6.ip6prefix' should be manually set by this script.
# This decision is based on the user's ISP contract type (speed, presence of Hikari Denwa),
# as these factors typically influence whether IPv6 prefixes are delegated via DHCPv6-PD
# or if a static /64 prefix is provided via RA.
#
# The general guideline provided to the user for selection is summarized as follows:
#
# | No. | ISP Speed (Approx) | Hikari Denwa Contract | WAN6 IPv6 Prefix Acquisition (Typical Assumption)      | Manual 'network.wan6.ip6prefix' Setting by Script?     |
# |:---:|:-------------------|:----------------------|:-------------------------------------------------------|:-------------------------------------------------------|
# |  1  | 1Gbps              | No                    | ISP provides /64 via RA (No or limited DHCPv6-PD).     | YES (Script will set '${CE_NETWORK_PREFIX_FOR_WAN6}::/64'). |
# |  2  | 1Gbps              | Yes                   | ISP delegates /56 (or similar) via DHCPv6-PD.          | NO (Script expects prefix to be acquired via DHCPv6-PD). |
# |  3  | 10Gbps             | No                    | ISP delegates /56 (or similar) via DHCPv6-PD.          | NO (Script expects prefix to be acquired via DHCPv6-PD). |
# |  4  | 10Gbps             | Yes                   | ISP delegates /56 (or similar) via DHCPv6-PD.          | NO (Script expects prefix to be acquired via DHCPv6-PD). |
#
# The user will be asked if their situation corresponds to No.1.
# Based on their 'y' or 'n' response, a global variable (e.g., USER_REQUESTS_MANUAL_WAN6_PREFIX)
# will be set. The mape_config() function will then use this variable to conditionally
# execute 'uci set network.wan6.ip6prefix...' or 'uci delete network.wan6.ip6prefix'.
#
# This function takes no arguments.
# It sets a global variable reflecting the user's choice.
mape_config() {

    local WANMAP='wanmap' # 設定セクション名
    local ZONE_NO='1'
    local wan_firewall_zone_name='wan'
    local osversion_file="${CACHE_DIR}/osversion.ch"
    local osversion=""
    
    # 設定のバックアップ作成
    debug_log "DEBUG" "Backing up configuration files..."
    cp /etc/config/network /etc/config/network.map-e.bak && debug_log "DEBUG" "network backup created." || debug_log "DEBUG" "Failed to backup network config."
    cp /etc/config/dhcp /etc/config/dhcp.map-e.bak && debug_log "DEBUG" "dhcp backup created." || debug_log "DEBUG" "Failed to backup dhcp config."
    cp /etc/config/firewall /etc/config/firewall.map-e.bak && debug_log "DEBUG" "firewall backup created." || debug_log "DEBUG" "Failed to backup firewall config."

    debug_log "DEBUG" "Applying MAP-E configuration using UCI (strictly adhering to user-defined versioning rules)"

    # 既存のwanインターフェースの自動起動を停止
    uci set network.wan.auto='0'

    # --- DHCP LAN 設定 ---
    uci set dhcp.lan.dhcpv6='server'
    uci set dhcp.lan.ra='server'
    uci set dhcp.lan.ndp='disabled'
    uci set dhcp.lan.force='1'
    uci set dhcp.lan.ra_slaac='1'
    uci delete dhcp.lan.ra_flags
    uci add_list dhcp.lan.ra_flags='managed-config'
    uci add_list dhcp.lan.ra_flags='other-config'
    uci -q delete dhcp.lan.ra_management
    uci -q delete dhcp.lan.ra_default

    # --- DHCP WAN6 設定 ---
    uci set dhcp.wan6=dhcp
    uci set dhcp.wan6.master='1'
    uci set dhcp.wan6.ra='relay'
    uci set dhcp.wan6.dhcpv6='relay'
    uci set dhcp.wan6.ndp='relay'

    # --- WAN6 インターフェース設定 ---
    uci set network.wan6.proto='dhcpv6'
    uci set network.wan6.reqaddress='try'
    uci set network.wan6.reqprefix='auto'
    
    # --- WANMAP (MAP-E) インターフェース設定 ---
    uci set network.${WANMAP}=interface
    uci set network.${WANMAP}.proto='map'
    uci set network.${WANMAP}.maptype='map-e'
    uci set network.${WANMAP}.peeraddr="${BR}"
    uci set network.${WANMAP}.ipaddr="${IPV4}"
    uci set network.${WANMAP}.ip4prefixlen="${IP4PREFIXLEN}"
    uci set network.${WANMAP}.ip6prefix="${IP6PFX}::"
    uci set network.${WANMAP}.ip6prefixlen="${IP6PREFIXLEN}"
    uci set network.${WANMAP}.ealen="${EALEN}"
    uci set network.${WANMAP}.psidlen="${PSIDLEN}"
    uci set network.${WANMAP}.offset="${OFFSET}"
    uci set network.${WANMAP}.mtu='1460'
    uci set network.${WANMAP}.encaplimit='ignore'

    # The following line sets a static IPv6 prefix for the wan6 interface.
    # In environments where a prefix is delegated via DHCPv6-PD (e.g., /56 from Plala 10G),
    # manually setting ip6prefix might be unnecessary or could cause conflicts.
    # If your ISP provides a prefix via PD and wan6 gets it automatically,
    # you should KEEP THIS LINE COMMENTED OUT.
    # If you have a static /64 prefix assignment or if PD is not working as expected,
    # you might need to uncomment and use this line.
    # uci set network.wan6.ip6prefix="${IPV6PREFIX}/64"
    
    # --- バージョン固有設定 ---
    if echo "$osversion" | grep -q "^19"; then
        debug_log "DEBUG" "Applying settings for OpenWrt 19.x compatible version"
        # 19系の場合:
        uci -q delete network.${WANMAP}.tunlink 
        uci add_list network.${WANMAP}.tunlink='wan6'
    else
        # 19系以外 (または osversion.ch が存在しない/空の場合)
        debug_log "DEBUG" "Applying settings for OpenWrt non-19.x version or undefined version"
        uci set dhcp.wan6.interface='wan6'
        uci set dhcp.wan6.ignore='1'
        uci set network.${WANMAP}.legacymap='1'
        uci set network.${WANMAP}.tunlink='wan6' 
    fi
    
    # --- ファイアウォール設定 ---
    uci del_list firewall.@zone[${ZONE_NO}].network='wan'
    uci del_list firewall.@zone[${ZONE_NO}].network=${WANMAP}
    uci add_list firewall.@zone[${ZONE_NO}].network=${WANMAP}
        
    # 設定の保存
    debug_log "DEBUG" "Committing UCI changes..."
    local commit_ok=1
    if ! uci commit network; then debug_log "ERROR" "Failed to commit network."; commit_ok=0; fi
    if ! uci commit dhcp; then debug_log "ERROR" "Failed to commit dhcp."; commit_ok=0; fi
    if ! uci commit firewall; then debug_log "ERROR" "Failed to commit firewall."; commit_ok=0; fi

    if [ "$commit_ok" -eq 1 ]; then
        debug_log "DEBUG" "All UCI sections committed successfully."
    else
        debug_log "ERROR" "One or more UCI sections failed to commit."
    fi
    
    return 0
}

check_pd() {
    local max_wait_seconds=45
    local interval_seconds=3
    local elapsed_seconds=0
    local current_delegated_prefix=""

    # NET_IF6 の存在チェック
    if [ -z "$NET_IF6" ]; then
        debug_log "DEBUG" "check_pd: NET_IF6 (WAN IPv6 interface name for PD) is not set."
        # スピナー開始前なので、ここではスピナー停止は不要
        return 4
    fi

    local display_wan_ip=""
    if [ -n "$NEW_IP6_PREFIX" ]; then
        display_wan_ip="$NEW_IP6_PREFIX"
    else
        display_wan_ip="N/A"
    fi

    # スピナー開始
    start_spinner "$(color blue "$(get_message "MSG_PD_CHECKING" "p=$display_wan_ip")")"
    debug_log "DEBUG" "check_pd: Starting PD check on interface '${NET_IF6}'. Displaying WAN IP: '${display_wan_ip}'. Max wait: ${max_wait_seconds}s, Interval: ${interval_seconds}s."

    while [ "$elapsed_seconds" -lt "$max_wait_seconds" ]; do
        network_get_prefix6 current_delegated_prefix "${NET_IF6}"
        if [ -n "$current_delegated_prefix" ]; then
            debug_log "DEBUG" "check_pd: PD acquired automatically on '${NET_IF6}': ${current_delegated_prefix}"
            stop_spinner "$(get_message "MSG_PD_ACQUIRED")" "success" # 自動PD成功時のスピナー停止
            return 0
        fi

        debug_log "DEBUG" "check_pd: PD not yet acquired on '${NET_IF6}'. Time elapsed: ${elapsed_seconds}s. Waiting for ${interval_seconds}s."
        sleep "$interval_seconds"
        elapsed_seconds=$((elapsed_seconds + interval_seconds))
    done

    # PD自動取得タイムアウト
    debug_log "DEBUG" "check_pd: PD auto-acquisition timed out on '${NET_IF6}' after ${max_wait_seconds} seconds."
    debug_log "DEBUG" "check_pd: Attempting to set manual prefix using IPV6PREFIX."

    if [ -z "$IPV6PREFIX" ]; then
        debug_log "DEBUG" "check_pd: IPV6PREFIX is not set. Cannot apply manual prefix."
        # 提案: IPV6PREFIX未設定の場合もスピナーを停止
        if [ -n "$SPINNER_PID" ]; then # スピナーが起動している場合のみ停止を試みる
            stop_spinner "$(get_message "MSG_PD_MANUAL_FAIL_NO_PREFIX")" "failure"
        fi
        return 2
    fi

    debug_log "DEBUG" "check_pd: Setting network.wan6.ip6prefix to '${IPV6PREFIX}/64'."
    uci -q set network.wan6.ip6prefix="${IPV6PREFIX}/64"

    debug_log "DEBUG" "check_pd: Committing network configuration."
    if uci -q commit network; then
        debug_log "DEBUG" "check_pd: Manual prefix set and network configuration committed successfully."
        # 変更点: echoでのメッセージ表示を、手動PD成功時のスピナー停止に置き換え
        if [ -n "$SPINNER_PID" ]; then
            stop_spinner "$(get_message "MSG_PD_MANUAL_CONFIG_SUCCESS")" "success"
        fi
        return 1
    else
        debug_log "DEBUG" "check_pd: Failed to commit network configuration after setting manual prefix."
        # 提案: uci commit失敗の場合もスピナーを停止
        if [ -n "$SPINNER_PID" ]; then
            stop_spinner "$(get_message "MSG_PD_MANUAL_FAIL_COMMIT")" "failure"
        fi
        return 3
    fi
}

replace_map_sh() {
    local proto_script_path="/lib/netifd/proto/map.sh"
    local backup_script_path="${proto_script_path}.bak"
    local osversion_file="${CACHE_DIR}/osversion.ch"
    local osversion=""
    local source_url=""
    local wget_rc
    local chmod_rc

    debug_log "DEBUG" "replace_map_sh: Function started. Method: cp backup, then direct wget overwrite with -6."

    # 1. OSバージョンに基づいてソースURLを決定
    if [ -f "$osversion_file" ]; then
        osversion=$(cat "$osversion_file")
        debug_log "DEBUG" "replace_map_sh: OS Version from '$osversion_file': $osversion"
    else
        osversion="unknown"
        debug_log "DEBUG" "replace_map_sh: OS version file '$osversion_file' not found. Using default: $osversion"
    fi

    if echo "$osversion" | grep -q "^19"; then
        source_url="https://raw.githubusercontent.com/site-u2023/map-e/main/map.sh.19"
    else
        source_url="https://raw.githubusercontent.com/site-u2023/map-e/main/map.sh.new"
    fi
    debug_log "DEBUG" "replace_map_sh: Determined source URL: $source_url"

    # 2. 既存のスクリプトをバックアップ (cp)
    if [ -f "$proto_script_path" ]; then
        debug_log "DEBUG" "replace_map_sh: Attempting to back up '$proto_script_path' to '$backup_script_path'."
        if command cp "$proto_script_path" "$backup_script_path"; then
            debug_log "DEBUG" "replace_map_sh: Backup successful: '$backup_script_path' created."
        else
            local cp_rc=$?
            debug_log "DEBUG" "replace_map_sh: Backup FAILED for '$proto_script_path'. 'cp' exit code: $cp_rc."
        fi
    else
        debug_log "DEBUG" "replace_map_sh: Original script '$proto_script_path' not found. Skipping backup."
    fi

    # 3. 新しいスクリプトをダウンロードして直接上書き (wget -O、IPタイプ -6 固定)
    debug_log "DEBUG" "replace_map_sh: Attempting to download from '$source_url' to '$proto_script_path' using wget with -6 option."
    
    command wget -q ${WGET_IPV_OPT} --no-check-certificate -O "$proto_script_path" "$source_url"
    wget_rc=$?
    debug_log "DEBUG" "replace_map_sh: wget command finished. Exit code: $wget_rc."

    if [ "$wget_rc" -eq 0 ]; then
        if [ -s "$proto_script_path" ]; then
            debug_log "DEBUG" "replace_map_sh: Download successful. '$proto_script_path' has been updated and is not empty."
            
            # 4. 実行権限を付与
            debug_log "DEBUG" "replace_map_sh: Setting execute permission on '$proto_script_path'."
            if command chmod +x "$proto_script_path"; then
                debug_log "DEBUG" "replace_map_sh: Execute permission set successfully for '$proto_script_path'."
                debug_log "DEBUG" "replace_map_sh: Function finished successfully."
                
                if type get_message > /dev/null 2>&1; then
                    printf "%s\n" "$(color green "$(get_message "MSG_MAP_SH_UPDATE_SUCCESS")")"
                fi
                return 0 # 全て成功
            else
                local chmod_rc=$?
                debug_log "DEBUG" "replace_map_sh: chmod +x FAILED for '$proto_script_path'. Exit code: $chmod_rc."
                return 2 # chmod失敗 (ダウンロードは成功)
            fi
        else
            debug_log "DEBUG" "replace_map_sh: wget reported success (exit code 0), but the downloaded file '$proto_script_path' is EMPTY."
            return 1 # ダウンロードしたがファイルが空
        fi
    else
        debug_log "DEBUG" "replace_map_sh: wget download FAILED. Exit code: $wget_rc."
        return 1 # wget失敗
    fi
}

# MAP-E設定情報を表示する関数
mape_display() {
    
    printf "\n"
    printf "%s\n" "$(color magenta "(config-softwire)# missing233")"

    printf "\n"
    printf "%s\n" "$(color blue "Prefix Information:")" # "プレフィックス情報:"
    printf "  IPv6 Prefix: %s\n" "$NEW_IP6_PREFIX" # "  IPv6プレフィックス: $NEW_IP6_PREFIX"
    printf "  CE IPv6 Address: %s\n" "$CE" # "  CE IPv6アドレス: $CE"
    printf "  IPv4 Address: %s\n" "$IPADDR" # "  IPv4アドレス: $IPADDR"
    printf "  PSID (Decimal): %s\n" "$PSID" # "  PSID値(10進数): $PSID"

    printf "\n"
    printf "%s\n" "$(color blue "OpenWrt Configuration Values:")" # "OpenWrt設定値:"
    printf "  option peeraddr '%s'\n" "$BR" # BRが空の場合もあるためクォート
    printf "  option ipaddr %s\n" "$IPV4"
    printf "  option ip4prefixlen '%s'\n" "$IP4PREFIXLEN"
    printf "  option ip6prefix '%s::'\n" "$IP6PFX" # IP6PFXが空の場合もあるためクォート
    printf "  option ip6prefixlen '%s'\n" "$IP6PREFIXLEN"
    printf "  option ealen '%s'\n" "$EALEN"
    printf "  option psidlen '%s'\n" "$PSIDLEN"
    printf "  option offset '%s'\n" "$OFFSET"
    printf "\n"
    printf "  export LEGACY=1\n"

    # ポート情報の計算を最適化
    local max_port_blocks=$(( (1 << OFFSET) ))
    local ports_per_block=$(( 1 << (16 - OFFSET - PSIDLEN) ))
    local total_ports=$(( ports_per_block * ((1 << OFFSET) - 1) )) 
    local port_start_for_A1=$(( (1 << (16 - OFFSET)) | (PSID << (16 - OFFSET - PSIDLEN)) )) 

    debug_log "DEBUG" "Port calculation for display: blocks=$max_port_blocks, ports_per_block=$ports_per_block, total_ports=$total_ports, first_port_start_A1=$port_start_for_A1" 

    printf "\n"
    printf "%s\n" "$(color blue "Port Information:")" # "ポート情報:"
    printf "  Available Ports: %s\n" "$total_ports" # "  利用可能なポート数: $total_ports"

    # ポート範囲を表示（PORTSをバッファリングして最適化）
    printf "\n"
    printf "%s\n" "$(color blue "Port Ranges:")" # "ポート範囲:"
    
    # PORTSが既にmape_mold()で計算済みかつ正常な場合は、それを表示
    if [ -n "$PORTS" ]; then
        # ポート範囲の各行の先頭にスペースを追加し、エスケープシーケンスを解釈
        printf "  %b\n" "$(echo "$PORTS" | sed 's/\\n/\\n  /g')"
    else
        # PORTSが空の場合のフォールバック処理（再計算）
        local shift_bits=$(( 16 - OFFSET ))
        local psid_shift=$(( 16 - OFFSET - PSIDLEN ))
        if [ "$psid_shift" -lt 0 ]; then
            psid_shift=0
        fi
        local port_range_size=$(( 1 << psid_shift ))
        local port_max_index=$(( (1 << OFFSET) - 1 )) # A=1 から AMAX まで
        local line_buffer=""
        local items_in_line=0
        local max_items_per_line=3 # 現在のロジックに合わせる
        
        for A in $(seq 1 "$port_max_index"); do
            local port_base=$(( A << shift_bits ))
            local psid_part=$(( PSID << psid_shift ))
            local port_start_val=$(( port_base | psid_part )) # 変数名を変更
            local port_end_val=$(( port_start_val + port_range_size - 1 )) # 変数名を変更
            
            # バッファに追加
            if [ "$items_in_line" -eq 0 ]; then
                line_buffer="${port_start_val}-${port_end_val}"
            else
                line_buffer="${line_buffer} ${port_start_val}-${port_end_val}"
            fi
            
            items_in_line=$((items_in_line + 1))
            
            # 行ごとに出力（最大表示項目数に達したか、最後の項目の場合）
            if [ "$items_in_line" -ge "$max_items_per_line" ] || [ "$A" -eq "$port_max_index" ]; then
                printf "  %s\n" "$line_buffer" # echo を printf に変更
                line_buffer=""
                items_in_line=0
            fi
        done
    fi

    printf "\n%s\n" "$(color green "$(get_message "MSG_MAPE_PARAMS_CALC_SUCCESS")")"
    printf "%s\n" "$(color yellow "$(get_message "MSG_MAPE_APPLY_SUCCESS")")"
    read -r -n 1 -s
    
    return 0
}

# MAP-E設定のバックアップを復元する関数
# 戻り値:
# 0: 1つ以上のバックアップが正常に復元され、再起動プロセス開始
# 1: 復元対象のバックアップファイルが1つも見つからなかった / またはその他のエラー
# 2: 1つ以上のファイルの復元に失敗したが、処理は継続し再起動プロセス開始
restore_mape() {
    local backup_files_restored_count=0
    local backup_files_not_found_count=0
    local restore_failed_count=0
    local total_files_to_check=0
    local overall_restore_status=1 # 初期値を「失敗または何もせず」に設定

    # 対象ファイルとバックアップファイルのマッピング
    # 構造: "オリジナルファイル名:バックアップファイル名"
    local files_to_restore="
        /etc/config/network:/etc/config/network.map-e.bak
        /etc/config/dhcp:/etc/config/dhcp.map-e.bak
        /etc/config/firewall:/etc/config/firewall.map-e.bak
        /lib/netifd/proto/map.sh:/lib/netifd/proto/map.sh.bak
    "

    debug_log "DEBUG" "Starting restore_mape function." # 関数名を修正

    # 各ファイルの復元処理
    for item in $files_to_restore; do
        total_files_to_check=$((total_files_to_check + 1))
        local original_file
        local backup_file
        original_file=$(echo "$item" | cut -d':' -f1)
        backup_file=$(echo "$item" | cut -d':' -f2)

        if [ -f "$backup_file" ]; then
            debug_log "DEBUG" "Attempting to restore '$original_file' from '$backup_file'."
            if cp "$backup_file" "$original_file"; then
                debug_log "DEBUG" "Successfully restored '$original_file' from '$backup_file'."
                backup_files_restored_count=$((backup_files_restored_count + 1))
            else
                debug_log "DEBUG" "Failed to copy '$backup_file' to '$original_file'."
                restore_failed_count=$((restore_failed_count + 1))
            fi
        else
            debug_log "DEBUG" "Backup file '$backup_file' not found. Skipping restore for '$original_file'."
            backup_files_not_found_count=$((backup_files_not_found_count + 1))
        fi
    done

    debug_log "DEBUG" "Restore process summary: Total checked=$total_files_to_check, Restored=$backup_files_restored_count, Not found=$backup_files_not_found_count, Failed=$restore_failed_count."

    if [ "$restore_failed_count" -gt 0 ]; then
        debug_log "DEBUG" "Restore completed with errors."
        overall_restore_status=2 # 1つ以上のファイルの復元に失敗
    elif [ "$backup_files_restored_count" -gt 0 ]; then
        debug_log "DEBUG" "Restore completed successfully for at least one file."
        overall_restore_status=0 # 1つ以上のバックアップが正常に復元された
    else
        # この分岐は backup_files_not_found_count == total_files_to_check と同義
        debug_log "DEBUG" "No backup files were found to restore."
        overall_restore_status=1 # 復元対象のバックアップファイルが1つも見つからなかった
    fi

    # overall_restore_status が 0 (成功) または 2 (一部失敗だが復元試行はあった) の場合に後続処理を実行
    if [ "$overall_restore_status" -eq 0 ] || [ "$overall_restore_status" -eq 2 ]; then
        debug_log "DEBUG" "Attempting to remove 'map' package as part of restore process."
        if opkg remove map >/dev/null 2>&1; then
            debug_log "DEBUG" "'map' package removed successfully."
        else
            debug_log "DEBUG" "Failed to remove 'map' package or package was not installed. Continuing."
        fi
        
        printf "\n%s\n" "$(color green "$(get_message "MSG_MAPE_RESTORE_COMPLETE")")"
        printf "%s\n" "$(color yellow "$(get_message "MSG_MAPE_APPLY_SUCCESS")")"
        read -r -n 1 -s
        printf "\n"
        
        debug_log "DEBUG" "Rebooting system after restore."
        reboot
        return 0 # reboot が呼ばれるので、ここには到達しないはずだが念のため
    elif [ "$overall_restore_status" -eq 1 ]; then
        # バックアップファイルが見つからなかった場合
        printf "\n%s\n" "$(color yellow "$(get_message "MSG_NO_BACKUP_FOUND")")"
        return 1 # 失敗として返す
    fi
    
    # 通常はここまで来ないはずだが、万が一のためのフォールバック
    return "$overall_restore_status"
}

internet_map_main() {

    print_section_title
    
    # mapパッケージのインストール確認
    install_package map hidden
    
    # map.shダウンロード
    replace_map_sh
        
    # 実行
    mape_mold

    mape_config

    check_pd
    
    mape_display
    
    reboot

    return 0 # Explicitly exit with success status
}

# internet_map_main

