#!/bin/sh

SCRIPT_VERSION="2025.03.10-03-17"

echo -e "\033[1;35mCurrent Version: aios - Version: $SCRIPT_VERSION\033[0m"

# =========================================================
# 📌 OpenWrt / Alpine Linux POSIX-Compliant Shell Script
# 🚀 Last Update: 2025-02-21
#
# 🏷️ License: CC0 (Public Domain)
# 🎯 Compatibility: OpenWrt >= 19.07 (Tested on 24.10.0)
#
# ⚠️ IMPORTANT NOTICE:
# OpenWrt OS exclusively uses **Almquist Shell (ash)** and
# is **NOT** compatible with Bourne-Again Shell (bash).
#
# 📢 POSIX Compliance Guidelines:
# ✅ Use `[` instead of `[[` for conditions
# ✅ Use `$(command)` instead of backticks `` `command` ``
# ✅ Use `$(( ))` for arithmetic instead of `let`
# ✅ Define functions as `func_name() {}` (no `function` keyword)
# ✅ No associative arrays (`declare -A` is NOT supported)
# ✅ No here-strings (`<<<` is NOT supported)
# ✅ No `-v` flag in `test` or `[[`
#
# 🛠️ Keep it simple, POSIX-compliant, and lightweight for OpenWrt!
# =========================================================
### =========================================================
### 📌 AI Assistance Request: Bug Fixing Procedure
### 
### When debugging or fixing errors in this script, follow these steps:
### 
### 1️⃣ Create a minimal test script to identify the bug.
### 2️⃣ Execute the test and verify the reproducibility of the error.
### 3️⃣ Fix the error and re-run the test to confirm the solution.
### 4️⃣ Apply the corrected code to the production environment.
### 
### ⚠️ DO NOT modify the main script without first confirming the fix 
###     through a dedicated test script.
### 
### 🛠️ Keep the debugging process structured, efficient, and reliable.
### =========================================================

DEV_NULL="${DEV_NULL:-on}"
# サイレントモード
# export DEV_NULL="on"
# 通常モード
# unset DEV_NULL

# 基本定数の設定 
BASE_WGET="${BASE_WGET:-wget --no-check-certificate -q -O}"
# BASE_WGET="${BASE_WGET:-wget -O}"
DEBUG_MODE="${DEBUG_MODE:-false}"
BIN_PATH=$(readlink -f "$0")
BIN_DIR="$(dirname "$BIN_PATH")"
BIN_FILE="$(basename "$BIN_PATH")"
BASE_URL="${BASE_URL:-https://raw.githubusercontent.com/site-u2023/aios/main}"
BASE_DIR="${BASE_DIR:-/tmp/aios}"
CACHE_DIR="${CACHE_DIR:-$BASE_DIR/cache}"
FEED_DIR="${FEED_DIR:-$BASE_DIR/feed}"
LOG_DIR="${LOG_DIR:-$BASE_DIR/logs}"
UPDATE_CACHE="${CACHE_DIR}/update.ch"
GITHUB_TOKEN_FILE="/etc/aios_token"

# 🔵　エラー・デバッグ・アップデート系　ここから　🔵-------------------------------------------------------------------------------------------------------------------------------------------
#########################################################################
# Last Update: 2025-02-16 16:00:00 (JST) 🚀
# "Clarity in errors, precision in handling. Every function must be robust."
#
# 【要件】
# 1. すべてのエラーメッセージを `messages.db` で管理し、多言語対応する。
# 2. `debug_log("ERROR", message)` も `message.db` を使用する。
# 3. `{file}`, `{version}` などの変数を動的に置換。
# 4. 影響範囲: `aios` & `common.sh`（矛盾なく適用）。
#########################################################################
handle_error() {
    local error_key="$1"
    local file="$2"
    local version="$3"
    local exit_required="${4:-no}"

    local error_message
    error_message=$(get_message "$error_key")

    # メッセージが取得できなかった場合のフォールバック
    if [ -z "$error_message" ]; then
        error_message="Unknown error occurred. Key: $error_key"
    fi

    # 変数を置換
    error_message=$(echo "$error_message" | sed -e "s/{file}/$file/g" -e "s/{version}/$version/g")

    # ログ記録 & 表示
    debug_log "ERROR" "$error_message"
    echo -e "$(color red "$error_message")"

    if [ "$exit_required" = "yes" ]; then
        debug_log "ERROR" "Critical error occurred, exiting: $error_message"
        exit 1
    else
        debug_log "DEBUG" "Non-critical error: $error_message"
        return 1
    fi
}

#########################################################################
# Last Update: 2025-02-16 16:10:00 (JST) 🚀
# "Logging with clarity, debugging with precision."
#
# 【要件】
# 1. すべてのログメッセージを `messages.db` で管理し、多言語対応する。
# 2. `{file}`, `{version}` などの変数を `sed` で動的に置換する。
# 3. `DEBUG_MODE` の設定に応じて `DEBUG`, `INFO`, `WARN`, `ERROR` を管理する。
# 4. 影響範囲: `aios` & `common.sh`（矛盾なく適用）。
#########################################################################
# デバッグログ関数の修正版（バージョン情報をクリーンに表示）
debug_log() {
    local level="$1"
    local message="$2"
    local file="$3"
    local version="$4"

    # `$1` にログレベルが指定されていない場合、デフォルトを `DEBUG` にする
    case "$level" in
        "DEBUG"|"INFO"|"WARN"|"ERROR") ;;  # 何もしない (正しいログレベル)
        "")
            level="DEBUG"
            message="$1"
            file="$2"
            version="$3"
            ;;
        *)
            message="$1"
            file="$2"
            version="$3"
            level="DEBUG"
            ;;
    esac

    # バージョン情報のクリーニング（メッセージにバージョン情報が含まれる場合）
    if echo "$message" | grep -q "version\|Version"; then
        # バージョン情報部分を抽出してクリーニング
        local cleaned_message="$message"
        # aios - [2025-03-10... のようなパターンを検出
        if echo "$message" | grep -q " - "; then
            local prefix=$(echo "$message" | sed 's/ - .*//')
            local version_part=$(echo "$message" | sed 's/.* - //')
            local cleaned_version=$(clean_version_string "$version_part")
            cleaned_message="$prefix - $cleaned_version"
        fi
        message="$cleaned_message"
    fi

    # 変数を置換
    message=$(echo "$message" | sed -e "s/{file}/$file/g" -e "s/{version}/$version/g")

    # ログレベル制御
    case "$DEBUG_LEVEL" in
        DEBUG)    allowed_levels="DEBUG INFO WARN ERROR" ;;
        INFO)     allowed_levels="INFO WARN ERROR" ;;
        WARN)     allowed_levels="WARN ERROR" ;;
        ERROR)    allowed_levels="ERROR" ;;
        *)        allowed_levels="ERROR" ;;
    esac

    if echo "$allowed_levels" | grep -q "$level"; then
        local timestamp
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        local log_message="[$timestamp] $level: $message"

        # カラー表示
        case "$level" in
            "ERROR") echo -e "$(color red "$log_message")" ;;
            "WARN") echo -e "$(color yellow "$log_message")" ;;
            "INFO") echo -e "$(color cyan "$log_message")" ;;
            "DEBUG") echo -e "$(color white "$log_message")" ;;
        esac

        # ログファイルに記録
        if [ "$AIOS_INITIALIZED" = "true" ]; then
            echo "$log_message" >> "$LOG_DIR/debug.log"
        fi
    fi
}

#########################################################################
# Last Update: 2025-02-16 17:30:00 (JST) 🚀
# "Debug with clarity, test with precision. Every log tells a story."
#
# 【要件】
# 1. `test_country_search()`, `test_timezone_search()`, `test_cache_contents()` を統合。
# 2. `debug_log()` を使用し、メッセージを `message.db` から取得。
# 3. `country.db` の検索結果が適切に出力されるか確認できるようにする。
# 4. 影響範囲: `common.sh` のみ（`aios` には影響なし）。
#########################################################################
test_debug_functions() {
    local test_type="$1"
    local test_input="$2"

    case "$test_type" in
        country)
            debug_log "DEBUG" "MSG_TEST_COUNTRY_SEARCH" "$test_input"
            if [ ! -f "${BASE_DIR}/country.db" ]; then
                handle_error "ERR_FILE_NOT_FOUND" "country.db"
                return 1
            fi
            awk -v query="$test_input" '
                $2 ~ query || $3 ~ query || $4 ~ query || $5 ~ query {
                    print NR, $2, $3, $4, $5, $6, $7, $8, $9
                }' "${BASE_DIR}/country.db"
            ;;

        timezone)
            debug_log "DEBUG" "MSG_TEST_TIMEZONE_SEARCH" "$test_input"
            if [ ! -f "${BASE_DIR}/country.db" ]; then
                handle_error "ERR_FILE_NOT_FOUND" "country.db"
                return 1
            fi
            awk -v country="$test_input" '
                $2 == country || $4 == country || $5 == country {
                    print NR, $5, $6, $7, $8, $9, $10, $11
                }' "${BASE_DIR}/country.db"
            ;;

        cache)
            debug_log "DEBUG" "MSG_TEST_CACHE_CONTENTS"
            for cache_file in "country_tmp.ch" "zone_tmp.ch"; do
                if [ -f "${CACHE_DIR}/$cache_file" ]; then
                    debug_log "DEBUG" "MSG_CACHE_CONTENTS" "$cache_file"
                    cat "${CACHE_DIR}/$cache_file"
                else
                    debug_log "DEBUG" "MSG_CACHE_NOT_FOUND" "$cache_file"
                fi
            done
            ;;
        
        *)
            debug_log "ERROR" "ERR_INVALID_ARGUMENT" "$test_type"
            return 1
            ;;
    esac
}

#########################################################################
# country_DEBUG: 選択された国と言語の詳細情報を表示
#########################################################################
country_DEBUG() {
    local country_DEBUG_file="${BASE_DIR}/country.ch"
    local selected_language_code=$(cat "${BASE_DIR}/check_country")
    if [ -f "$country_DEBUG_file" ]; then
        grep -w "$selected_language_code" "$country_DEBUG_file"
    else
        printf "%s\n" "$(color red "Country DEBUGrmation not found.")"
    fi
}

#########################################################################
# handle_exit: 正常終了メッセージを表示して終了
#########################################################################
handle_exit() {
    local message="$1"
    color yellow "$message"
    exit 0
}

# 🔴　エラー・デバッグ・アップデート系　ここまで　🔴-------------------------------------------------------------------------------------------------------------------------------------------

#########################################################################
# print_help: ヘルプメッセージを表示
#########################################################################
print_help() {
    echo "Usage: aios.sh [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -reset, --reset, -r     Reset all cached data"
    echo "  -help, --help, -h       Show this help message"
    echo "  ja, en, zh-cn, ...      Set language"
    echo ""
    echo "Examples:"
    echo "  sh aios.sh full ja       # Run in full mode with language set to Japanese"
    echo "  sh aios.sh full          # If language cache exists, use it; otherwise, prompt for language"
}

#########################################################################
# color: ANSI エスケープシーケンスを使って色付きメッセージを出力する関数
#########################################################################
color() {
    local color_code
    color_code=$(color_code_map "$1")
    shift
    echo -e "${color_code}$*$(color_code_map "reset")"
}

#########################################################################
# color_code_map: カラー名から ANSI エスケープシーケンスを返す関数
#########################################################################
color_code_map() {
    local color="$1"
    case "$color" in
        "red") echo "\033[1;31m" ;;
        "green") echo "\033[1;32m" ;;
        "yellow") echo "\033[1;33m" ;;
        "blue") echo "\033[1;34m" ;;
        "magenta") echo "\033[1;35m" ;;
        "cyan") echo "\033[1;36m" ;;
        "white") echo "\033[1;37m" ;;
        "red_underline") echo "\033[4;31m" ;;
        "green_underline") echo "\033[4;32m" ;;
        "yellow_underline") echo "\033[4;33m" ;;
        "blue_underline") echo "\033[4;34m" ;;
        "magenta_underline") echo "\033[4;35m" ;;
        "cyan_underline") echo "\033[4;36m" ;;
        "white_underline") echo "\033[4;37m" ;;
        "red_white") echo "\033[1;41m" ;;
        "green_white") echo "\033[1;42m" ;;
        "yellow_white") echo "\033[1;43m" ;;
        "blue_white") echo "\033[1;44m" ;;
        "magenta_white") echo "\033[1;45m" ;;
        "cyan_white") echo "\033[1;46m" ;;
        "white_black") echo "\033[7;40m" ;;
        "reset") echo "\033[0;39m" ;;
        *) echo "\033[0;39m" ;;  # デフォルトでリセット
    esac
}

#########################################################################
# check_openwrt: OpenWrtのバージョン確認・管理のみを担当
#########################################################################
check_openwrt() {
    local version_file="${CACHE_DIR}/openwrt.ch"

    # **キャッシュがあれば使用**
    if [ -f "$version_file" ]; then
        CURRENT_VERSION=$(cat "$version_file")
    else
        local raw_version=""
        local distrib_id=""

        # **① /etc/openwrt_release から取得（最優先）**
        if [ -f "/etc/openwrt_release" ]; then
            distrib_id=$(awk -F"'" '/DISTRIB_ID/ {print $2}' /etc/openwrt_release)
            
            # **GL.iNet カスタム版は弾く**
            if [ "$distrib_id" != "OpenWrt" ]; then
                handle_error "Unsupported OpenWrt version: $distrib_id (Only OpenWrt - supported)"
                exit 1  # 🚨 スクリプト全体を終了
            fi

            if grep -q "DISTRIB_RELEASE=" /etc/openwrt_release; then
                raw_version=$(awk -F"'" '/DISTRIB_RELEASE/ {print $2}' /etc/openwrt_release)
            fi
        fi

        # **② /etc/openwrt_version が存在すれば使用**
        if [ -z "$raw_version" ] && [ -f "/etc/openwrt_version" ]; then
            raw_version=$(cat /etc/openwrt_version)
        fi

        # **③ バージョンが取得できなければスクリプト全体を終了**
        if [ -z "$raw_version" ]; then
            handle_error "Could not determine OpenWrt version. Check system files."
            exit 1  # 🚨 スクリプト全体を終了
        fi

        # **④ バージョン表記の統一**
        CURRENT_VERSION=$(echo "$raw_version" | tr '-' '.')

        # **⑤ キャッシュに書き出し**
        echo "$CURRENT_VERSION" > "$version_file"
        chmod 444 "$version_file"  # 読み取り専用
    fi

    # **⑥ データベースにバージョンがあるか確認**
    if grep -q "^$CURRENT_VERSION=" "${BASE_DIR}/openwrt.db"; then
        local db_entry=$(grep "^$CURRENT_VERSION=" "${BASE_DIR}/openwrt.db" | cut -d'=' -f2)
        PACKAGE_MANAGER=$(echo "$db_entry" | cut -d'|' -f1)
        VERSION_STATUS=$(echo "$db_entry" | cut -d'|' -f2)
        echo -e "$(color green "OpnWrt version: $CURRENT_VERSION - supported ($VERSION_STATUS)")"
    else
        handle_error "Unsupported OpenWrt version: $CURRENT_VERSION"
        exit 1  # 🚨 スクリプト全体を終了
    fi
}

#########################################################################
# check_architecture: OpenWrtのアーキテクチャを確認・キャッシュ
#########################################################################
check_architecture() {
    local arch_file="${CACHE_DIR}/architecture.ch"

    # **キャッシュがあれば再取得しない**
    if [ -f "$arch_file" ]; then
        arch=$(cat "$arch_file" | tr -d '\r')
        debug_log "DEBUG" "Using cached architecture: $arch"
        return 0
    fi

    # **アーキテクチャを取得**
    local arch=$(uname -m)

    # **キャッシュに保存（アーキテクチャ名のみ）**
    echo "$arch" > "$arch_file"

    debug_log "DEBUG" "Architecture detected: $arch"
}

#########################################################################
# check_downloader: パッケージマネージャー判定（apk / opkg 対応）
#########################################################################
check_downloader() {
    if [ -f "${BASE_DIR}/downloader.ch" ]; then
        PACKAGE_MANAGER=$(cat "${CACHE_DIR}/downloader.ch")
        PACKAGE_EXTENSION=$(cat "${CACHE_DIR}/extension.ch")
    else
        if command -v apk >/dev/null 2>&1; then
            PACKAGE_MANAGER="apk"
            PACKAGE_EXTENSION="apk"
        elif command -v opkg >/dev/null 2>&1; then
            PACKAGE_MANAGER="opkg"
            PACKAGE_EXTENSION="ipk"
        else 
            PACKAGE_MANAGER="opkg"  # デフォルトをセット
            PACKAGE_EXTENSION="ipk" 
        fi
        echo "$PACKAGE_MANAGER" > "${CACHE_DIR}/downloader.ch"
        echo "$PACKAGE_EXTENSION" > "${CACHE_DIR}/extension.ch"
    fi
    echo -e "$(color green "Package Manager: $PACKAGE_MANAGER - supported (stable)")"
    echo -e "$(color green "Package Extension: $PACKAGE_EXTENSION - supported (stable)")"
}

#########################################################################
# Last Update: 2025-02-18 18:00:00 (JST) 🚀
# "Efficiency in retrieval, clarity in communication."
# get_message: システムメッセージを取得する関数
#
# 【要件】
# 1. **メッセージの取得ロジック**
#    - `$ACTIVE_LANGUAGE` を最優先で使用（`normalize_language()` で設定）
#    - `$ACTIVE_LANGUAGE` が未設定の場合は `US` をフォールバックとして使用
#
# 2. **メッセージ検索の順序**
#    ① `$ACTIVE_LANGUAGE|キー=` で `messages.db` を検索
#    ② `US|キー=` で `messages.db` を検索（フォールバック）
#    ③ どちらにも該当しない場合、`キー` をそのまま返す
#
# 3. **動作の最適化**
#    - `$ACTIVE_LANGUAGE` を直接参照し、キャッシュ (`message.ch`) には依存しない
#    - `$quiet_flag` に `"quiet"` が指定された場合、出力せずに `return 0`
#
# 4. **メンテナンス**
#    - 言語取得ロジックを `normalize_language()` に統一し、責務を分離
#    - `get_message()` は「取得するだけ」に特化し、書き込み・設定は行わない
#
# 5. **影響範囲**
#    - `common.sh` 内のメッセージ取得全般（`debug_log()` 含む）
#    - `messages.db` のフォーマット変更時も `get_message()` の修正は不要
#########################################################################
get_message() {
    local key="$1"
    local params="$2"
    local quiet_flag="$3"
    local message_db="${BASE_DIR}/messages.db"
    local message_cache="${CACHE_DIR}/message.ch"
    local lang="US"  # デフォルトはUS

    # message.chから言語を読み取る
    if [ -f "$message_cache" ]; then
        lang=$(cat "$message_cache")
    fi

    # `messages.db` が存在しない場合、キーそのままを返す
    if [ ! -f "$message_db" ]; then
        message="$key"
    else
        # 言語優先検索
        message=$(grep "^${lang}|${key}=" "$message_db" | cut -d'=' -f2-)

        # フォールバック検索
        if [ -z "$message" ]; then
            message=$(grep "^US|${key}=" "$message_db" | cut -d'=' -f2-)
        fi

        # それでも見つからなければ、キーそのままを返す
        if [ -z "$message" ]; then
            message="$key"
        fi
    fi

    # パラメータ置換
    if [ -n "$params" ]; then
        for param in $params; do
            key=$(echo "$param" | cut -d'=' -f1)
            value=$(echo "$param" | cut -d'=' -f2)
            # `sed` コマンドで使用する際に `value` をエスケープする
            escaped_value=$(echo "$value" | sed -e 's/[\/&]/\\&/g')
            message=$(echo "$message" | sed -e "s/{$key}/$escaped_value/g")
        done
    fi

    # quiet モード対応
    if [ "$quiet_flag" = "quiet" ]; then
        return 0
    else
        echo "$message"
    fi
}

# 🔵　トークン系　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------

# GitHub API呼び出し（デバッグ強化版）
github_api_request() {
    local endpoint="$1"
    local token=$(get_github_token)
    local response=""
    
    if [ -n "$token" ]; then
        debug_log "DEBUG" "Attempting authenticated request with token (${#token} chars)"
        response=$(wget -q --header="Authorization: token $token" \
            --header="Accept: application/vnd.github.v3+json" \
            -O- "https://api.github.com/$endpoint" 2>/dev/null)
            
        # レスポンス検証 - リミットチェック
        if echo "$response" | grep -q '"message":"API rate limit exceeded'; then
            debug_log "WARN" "GitHub API rate limit exceeded"
            return 1
        fi
        
        # 認証エラーチェック
        if echo "$response" | grep -q '"message":"Bad credentials"'; then
            debug_log "ERROR" "GitHub API authentication failed: Bad credentials"
            return 2
        fi
        
        # その他エラーチェック
        if echo "$response" | grep -q '"message":"'; then
            local error_msg=$(echo "$response" | grep -o '"message":"[^"]*"' | cut -d':' -f2- | tr -d '"')
            debug_log "ERROR" "GitHub API error: $error_msg"
            return 3
        fi
        
        # 成功
        echo "$response"
        return 0
    else
        debug_log "DEBUG" "No token found, using unauthenticated request"
        wget -q -O- "https://api.github.com/$endpoint" 2>/dev/null
        return $?
    fi
}

# 改善されたトークン取得関数
get_github_token() {
    if [ -f "$GITHUB_TOKEN_FILE" ] && [ -r "$GITHUB_TOKEN_FILE" ]; then
        # 1. 生のトークンを取得
        local raw_token=$(cat "$GITHUB_TOKEN_FILE")
        
        # 2. 複数の処理方法を試す
        
        # 方法1: 改行と空白を削除
        local token=$(echo "$raw_token" | tr -d '\n\r\t ')
        
        # 方法2: ghp_で始まる40文字の英数字パターンを抽出
        if [ -z "$token" ] || [ ${#token} -ne 40 ]; then
            token=$(echo "$raw_token" | grep -o 'ghp_[a-zA-Z0-9]\{36\}')
        fi
        
        # 最終チェック
        if [ -n "$token" ] && [ ${#token} -eq 40 ]; then
            echo "$token"
            return 0
        else
            debug_log "WARN" "Invalid token format in $GITHUB_TOKEN_FILE"
        fi
    fi
    
    # 環境変数からの取得
    if [ -n "$GITHUB_TOKEN" ]; then
        echo "$GITHUB_TOKEN"
        return 0
    fi
    
    return 1
}

# トークン保存関数
save_github_token() {
    token="$1"
    
    if [ -z "$token" ]; then
        debug_log "ERROR" "Empty token provided, cannot save"
        return 1
    fi
    
    # トークンを保存して権限を設定
    echo "$token" > "$GITHUB_TOKEN_FILE"
    chmod 600 "$GITHUB_TOKEN_FILE"
    
    if [ $? -eq 0 ]; then
        debug_log "INFO" "GitHub token saved to $GITHUB_TOKEN_FILE"
        return 0
    else
        debug_log "ERROR" "Failed to save token to $GITHUB_TOKEN_FILE"
        return 1
    fi
}

# GitHub API呼び出し（トークン対応版）
github_api() {
    endpoint="$1"
    
    # トークンを取得
    token=$(get_github_token)
    
    if [ -n "$token" ]; then
        # トークンがある場合は認証付きリクエスト
        debug_log "DEBUG" "Using authenticated GitHub API request"
        wget -qO- --header="Authorization: token $token" \
            "https://api.github.com/$endpoint" 2>/dev/null
    else
        # トークンがない場合は通常リクエスト
        debug_log "DEBUG" "Using unauthenticated GitHub API request"
        wget -qO- "https://api.github.com/$endpoint" 2>/dev/null
    fi
}

# トークン設定コマンド（OpenWrt互換性強化版）
setup_github_token() {
    echo "GitHub API Token Setup"
    echo "======================"
    echo "This will save a GitHub Personal Access Token to $GITHUB_TOKEN_FILE"
    echo "The token will be used for API requests to avoid rate limits."
    echo ""
    
    # sttyが利用可能かチェック
    if command -v stty >/dev/null 2>&1; then
        # sttyが利用可能な場合、非表示モードを使用
        printf "Enter your GitHub Personal Access Token: "
        stty -echo
        read -r token
        stty echo
        echo ""  # 改行
    else
        # sttyが利用できない場合の代替方法
        echo "NOTE: Your input will be visible as you type (stty not available)"
        printf "Enter your GitHub Personal Access Token: "
        read -r token
        echo ""
    fi
    
    if [ -n "$token" ]; then
        if save_github_token "$token"; then
            echo "Token has been saved successfully!"
            echo "API requests will now use authentication."
        else
            echo "Failed to save token. Please check permissions."
        fi
    else
        echo "No token entered. Operation cancelled."
    fi
}

# 🔴　トークン系　ここまで　🔴-------------------------------------------------------------------------------------------------------------------------------------------


# 🔵　ダウンロード系　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------
#########################################################################
# Last Update: 2025-02-18 23:00:00 (JST) 🚀
# "Standardizing version formatting for consistency."
#
# 【要件】
# 1. **バージョン番号のフォーマットを統一**
#    - `YYYY.MM.DD-自由形式`
#    - `YYYYMMDDHHMMSS-自由形式`
#    - 許可される区切り文字: `- . , ; : 空白`
#
# 2. **処理内容**
#    - **許可された文字のみを抽出**
#    - **先頭のゼロを削除（例: `02` → `2`）**
#    - **前後の余計なスペースを削除**
#
# 3. **適用対象**
#    - **`download()`**: **スクリプトバージョンの取得・比較**
#    - **`compare_versions()`**: **バージョン比較時のフォーマット統一**
#
# 4. **適用しない対象**
#    - **バージョン番号の解釈を変更しない（順番の入れ替えはしない）**
#    - **日付以外の文字列は削除せず、フォーマットの標準化のみ行う**
#
# 5. **依存関係**
#    - `normalize_input()` を使用し、iconv による処理を統一
#
# 6. **影響範囲**
#    - `common.sh` に統合し、`download()` & `compare_versions()` で使用
#########################################################################
# Last Update: 2025-03-04 12:45:00 (JST) 🚀
# "Efficient downloading with precise versioning and silent modes."
#
# 【要件】
# 1. BASE_WGET を使用してファイルをダウンロードする。
# 2. hidden オプション:
#    - ダウンロードの成否ログを記録するが、既存ファイルがある場合は出力を抑制する。
# 3. quiet オプション:
#    - check_option() で設定された QUIET_MODE に従い、すべてのログを抑制する。
# 4. chmod オプション:
#    - ダウンロード後、対象ファイルに実行権限 (chmod +x) を付与する。
# 5. read オプション:
#    - ダウンロード後、対象ファイルを読み込む（source）する。（ただし、ファイル名が *common*.sh に一致する場合は自動で読み込む）
#    - デフォルトでは読み込まない。
# 6. 引数の順序は自由（hidden, quiet, chmod, read の順番は任意）。
# 7. wget のエラーハンドリングを行い、失敗時の詳細を debug_log() に記録する。
# 8. 影響範囲: common.sh の download() のみ（他の関数には影響なし）。
#########################################################################
decode_base64() {
    input="$1"
    output=""
    decoder_type=""
    base64_cache="${CACHE_DIR}/base64.ch"
    
    # キャッシュファイルから以前検出したデコーダーを確認
    if [ -f "$base64_cache" ]; then
        # shellcheck disable=SC1090
        . "$base64_cache"
        debug_log "DEBUG" "base64: using cached decoder: $BASE64_DECODER"
    else
        # 利用可能なデコーダーを検索
        if command -v base64 >/dev/null 2>&1; then
            BASE64_DECODER="coreutils"
            debug_log "DEBUG" "base64: found coreutils-base64"
        elif command -v openssl >/dev/null 2>&1; then
            BASE64_DECODER="openssl" 
            debug_log "DEBUG" "base64: found openssl"
        else
            debug_log "WARN" "base64: no decoder found, attempting to install coreutils-base64"
            
            # DEBUGモードの場合は通常表示、それ以外はサイレント
            if [ "$DEBUG_MODE" = "true" ]; then
                debug_log "INFO" "Running: opkg update"
                opkg update
                debug_log "INFO" "Running: opkg install coreutils-base64"
                opkg install coreutils-base64
            else
                # サイレントでパッケージをインストール試行
                opkg update >/dev/null 2>&1
                opkg install coreutils-base64 >/dev/null 2>&1
            fi
            
            # インストール成功したか確認
            if command -v base64 >/dev/null 2>&1; then
                BASE64_DECODER="coreutils"
                debug_log "INFO" "base64: successfully installed coreutils-base64"
            else
                debug_log "ERROR" "base64: failed to install decoder, decode operation will fail"
                BASE64_DECODER="none"
            fi
        fi
        
        # 検出結果をキャッシュファイルに保存
        mkdir -p "$CACHE_DIR"
        echo "BASE64_DECODER=\"$BASE64_DECODER\"" > "$base64_cache"
    fi
    
    # デコード実行
    case "$BASE64_DECODER" in
        "coreutils")
            output=$(echo "$input" | base64 -d 2>/dev/null)
            decoder_type="coreutils-base64"
            ;;
        "openssl")
            output=$(echo "$input" | openssl base64 -d 2>/dev/null)
            decoder_type="openssl"
            ;;
        *)
            debug_log "ERROR" "base64: no decoder available"
            return 1
            ;;
    esac
    
    # 結果を確認
    if [ $? -eq 0 ] && [ -n "$output" ]; then
        debug_log "DEBUG" "base64: decoded with $decoder_type"
        echo "$output"
        return 0
    else
        debug_log "ERROR" "base64: decode failed with $decoder_type"
        return 1
    fi
}

# 認証状態を正確に判定する関数
check_token_status() {
    echo "========== GitHub Token Status =========="
    
    # トークンファイルの存在確認
    if [ -f "$GITHUB_TOKEN_FILE" ]; then
        echo "Token file: $GITHUB_TOKEN_FILE (EXISTS)"
        ls -l "$GITHUB_TOKEN_FILE"
        
        # トークンの先頭部分だけを表示（セキュリティのため）
        local token=$(cat "$GITHUB_TOKEN_FILE" | tr -d '\n\r\t ')
        local token_preview=${token:0:5}
        echo "Token starts with: ${token_preview}..."
        
        # レート制限の確認
        local rate_info=$(wget -q -O- --header="Authorization: token $token" "https://api.github.com/rate_limit" 2>/dev/null)
        
        if [ -n "$rate_info" ]; then
            # JSON出力から値を抽出する際に、スペースに関係なく取得できるよう改良
            local limit=$(echo "$rate_info" | grep -o '"limit"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*')
            local remaining=$(echo "$rate_info" | grep -o '"remaining"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*')
            
            echo "Current rate limit: $limit"
            echo "Remaining requests: $remaining"
            
            # 認証状態の判断（より堅牢な比較）
            if [ -n "$limit" ] && [ "$limit" -gt 60 ]; then
                echo "Auth status: ✅ AUTHENTICATED (Higher limits active: $limit)"
            else
                echo "Auth status: ❌ UNAUTHENTICATED (Standard limits: $limit)"
            fi
        else
            echo "Could not retrieve rate limit information"
        fi
    else
        echo "Token file: $GITHUB_TOKEN_FILE (NOT FOUND)"
    fi
    
    echo "========================================"
}

# APIレート制限確認関数
check_api_rate_limit() {
    if [ "$DEBUG_MODE" = "true" ]; then
        api_info=$(wget -qO- "https://api.github.com/rate_limit" 2>/dev/null)
        if [ -n "$api_info" ]; then
            api_remaining=$(echo "$api_info" | grep -o '"core":{"limit":[0-9]*,"remaining":[0-9]*' | grep -o 'remaining":[0-9]*' | cut -d':' -f2)
            api_limit=$(echo "$api_info" | grep -o '"core":{"limit":[0-9]*,"remaining":[0-9]*' | grep -o 'limit":[0-9]*' | cut -d':' -f2)
            api_reset=$(echo "$api_info" | grep -o '"reset":[0-9]*' | head -1 | cut -d':' -f2)
            api_now=$(date +%s)
            
            if [ -n "$api_reset" ] && [ -n "$api_now" ]; then
                api_seconds=$(expr "$api_reset" - "$api_now")
                [ "$api_seconds" -lt 0 ] && api_seconds=0
                api_minutes=$(expr "$api_seconds" / 60)
                api_seconds=$(expr "$api_seconds" % 60)
                debug_log "DEBUG" "API Limits: Core ${api_remaining:-?}/${api_limit:-?}, Reset in ${api_minutes}m ${api_seconds}s"
            fi
        fi
    fi
    return 0
}

# バージョン文字列をクリーンアップする関数
clean_version_string() {
    local version_str="$1"
    
    # 1. 改行と復帰を削除
    local cleaned=$(echo "$version_str" | tr -d '\n\r')
    
    # 2. 角括弧を削除
    cleaned=$(echo "$cleaned" | sed 's/\[//g' | sed 's/\]//g')
    
    # 3. ANSIエスケープコードを削除（複数パターン対応）
    cleaned=$(echo "$cleaned" | sed -e 's/\x1b\[[0-9;]*m//g' -e 's/[0-9]\+;[0-9]\+m//g')
    
    # 4. 不必要な重複を削除（日付の重複など）
    cleaned=$(echo "$cleaned" | sed -e 's/\(20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]\)\1*/\1/g' -e 's/\(20[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\)\1*/\1/g')
    
    # 5. バージョンの一般的なフォーマットだけを抽出（日付-ハッシュ値）
    local version_pattern=$(echo "$cleaned" | grep -o '20[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]-[0-9a-zA-Z]\+' | head -1)
    
    # パターンが見つかった場合はそれを使用、見つからない場合はクリーン化した文字列を返す
    if [ -n "$version_pattern" ]; then
        echo "$version_pattern"
    else
        echo "$cleaned"
    fi
}

# GitHubコミットからバージョン情報を取得（完全版）
get_commit_version() {
    local file_path="$1"
    
    # リポジトリ情報を明示的に設定
    local repo_owner="site-u2023"
    local repo_name="aios"
    local api_url="repos/${repo_owner}/${repo_name}/commits?path=${file_path}&per_page=1"
    local commit_info=""
    local auth_method="direct"
    
    # トークンによるAPI認証
    local token=$(get_github_token)
    
    if [ -n "$token" ]; then
        debug_log "DEBUG" "Using token authentication for API request"
        commit_info=$(wget -qO- --header="Authorization: token $token" \
            "https://api.github.com/$api_url" 2>/dev/null)
            
        # 判定ロジックの修正: レスポンスが空でないことに加えて
        # SHA情報があるかを確認することで認証状態を正確に判定
	if [ -n "$commit_info" ] && (echo "$commit_info" | grep -q '"sha"' || echo "$commit_info" | grep -q '"commit"'); then
    	    auth_method="token"
    	    debug_log "DEBUG" "Token authentication successful"
	else
    	    # 詳細なデバッグ情報
    	    debug_log "DEBUG" "Response first 100 chars: $(echo "$commit_info" | head -c 100)"
    	    debug_log "WARN" "Token auth response lacks expected fields"
	fi
    else
        debug_log "DEBUG" "No token available, using direct API request"
        commit_info=$(wget -qO- "https://api.github.com/$api_url" 2>/dev/null)
    fi
    
    if [ -n "$commit_info" ]; then
        # 日付とSHAを抽出（改行を正しく処理するよう改善）
        local commit_date=$(echo "$commit_info" | tr -d '\n\r' | grep -o '"date": *"[^"]*"' | head -1 | sed 's/.*"date": *"\([^"]*\)".*/\1/')
        local commit_sha=$(echo "$commit_info" | tr -d '\n\r' | grep -o '"sha": *"[^"]*"' | head -1 | sed 's/.*"sha": *"\([^"]*\)".*/\1/' | cut -c 1-7)
        
        if [ -n "$commit_date" ] && [ -n "$commit_sha" ]; then
            # YYYY.MM.DD-SHA 形式に変換
            local formatted_date=$(echo "$commit_date" | sed 's/T.*Z//g;s/-/./g')
            local clean_version="${formatted_date}-${commit_sha}"
            
            debug_log "DEBUG" "Successfully extracted commit info: $clean_version"
            echo "$clean_version $auth_method"
            return 0
        fi
        debug_log "DEBUG" "Failed to extract commit info from response"
    else
        debug_log "DEBUG" "No API response received for: $file_path"
    fi
    
    # API取得失敗時は現在時刻を使用
    echo "$(date +%Y.%m.%d)-unknown ${auth_method}"
    return 1
}

# バージョン情報を安全に更新する関数（完全版）
update_file_version() {
    local file_name="$1"
    local version="$2"
    local script_file="$3"
    
    # バージョン文字列をクリーンアップ
    version=$(clean_version_string "$version")
    
    if [ ! -f "$script_file" ]; then
        printf "%s=%s\n" "${file_name}" "${version}" > "$script_file"
        return 0
    fi
    
    # 一時ファイルを使用した安全な書き換え
    local tmp_file="${script_file}.tmp"
    > "$tmp_file"  # 一時ファイルを初期化
    
    if grep -q "^${file_name}=" "$script_file"; then
        # 該当行を置換
        while IFS= read -r line; do
            if echo "$line" | grep -q "^${file_name}="; then
                echo "${file_name}=${version}" >> "$tmp_file"
            else
                echo "$line" >> "$tmp_file"
            fi
        done < "$script_file"
    else
        # ファイルをそのままコピーして新しいエントリを追加
        cat "$script_file" > "$tmp_file"
        echo "${file_name}=${version}" >> "$tmp_file"
    fi
    
    # 一時ファイルを元のファイルに移動
    mv "$tmp_file" "$script_file"
    
    return 0
}

# バージョン比較関数
version_is_newer() {
    local current="$1"
    local reference="$2"
    
    # どちらかが不明の場合は更新必要
    if echo "$current $reference" | grep -q "No version\|unknown"; then
        return 0
    fi
    
    # 日付部分を抽出（YYYY.MM.DD形式）- より堅牢な方法
    local current_date=$(echo "$current" | grep -o "[0-9][0-9][0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]" | head -1)
    local reference_date=$(echo "$reference" | grep -o "[0-9][0-9][0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]" | head -1)
    
    # 日付が抽出できなかった場合は更新が必要
    if [ -z "$current_date" ] || [ -z "$reference_date" ]; then
        return 0
    fi
    
    # 日付を数値に変換（区切り文字を削除）
    local current_num=$(echo "$current_date" | tr -d '.')
    local reference_num=$(echo "$reference_date" | tr -d '.')
    
    # 数値比較（日付形式）
    if [ "$current_num" -gt "$reference_num" ]; then
        return 0  # 現在のバージョンが新しい
    elif [ "$current_num" -lt "$reference_num" ]; then
        return 1  # リファレンスバージョンが新しい
    fi
    
    # 日付が同じ場合はSHA部分を比較
    local current_sha=$(echo "$current" | grep -o "\-[a-z0-9]*" | sed 's/^-//' | head -1)
    local reference_sha=$(echo "$reference" | grep -o "\-[a-z0-9]*" | sed 's/^-//' | head -1)
    
    if [ -n "$current_sha" ] && [ -n "$reference_sha" ] && [ "$current_sha" != "$reference_sha" ]; then
        return 0  # 異なるコミット
    fi
    
    return 1  # 同一バージョン
}

# ダウンロード関数
download() {
    # ファイル名を最初の引数として処理、残りはオプション
    local file_name="$1"
    shift
    
    # 設定変数
    local hidden_mode="false"
    local quiet_mode="${QUIET_MODE:-false}"
    local chmod_mode="false"
    local read_mode="false"
    local script_file="${CACHE_DIR}/script.ch"
    local dummy_version="No version control"
    
    # オプション引数の処理
    while [ $# -gt 0 ]; do
        case "$1" in
            hidden) hidden_mode="true" ;;
            quiet)  quiet_mode="true" ;;
            debug)  DEBUG_MODE="true" ;;
            chmod)  chmod_mode="true" ;;
            read)   read_mode="true" ;;
            *)      debug_log "WARN" "Unknown option: $1, ignoring" ;;
        esac
        shift
    done
    
    # パス設定
    local install_path="${BASE_DIR}/$file_name"
    local remote_url="${BASE_URL}/$file_name"
    
    # API制限チェック（デバッグモード時のみ）
    [ "$DEBUG_MODE" = "true" ] && check_api_rate_limit
    
    # バージョン情報の取得
    local remote_version_info=$(get_commit_version "$file_name")
    local remote_version=$(printf "%s" "$remote_version_info" | cut -d' ' -f1)
    local auth_method=$(printf "%s" "$remote_version_info" | cut -d' ' -f2)
    local local_version=""
    
    # ローカルバージョンの取得
    if [ -f "$script_file" ]; then
        local_version=$(grep "^${file_name}=" "$script_file" | cut -d'=' -f2)
    fi
    [ -z "$local_version" ] && local_version="$dummy_version"

    local clean_remote_version=$(clean_version_string "$remote_version")
    local clean_local_version=$(clean_version_string "$local_version")

    # 認証メッセージの設定
    local auth_message=""
    case "$auth_method" in
        token)    auth_message="via token auth" ;;
        standard) auth_message="via standard API" ;;
        *)        auth_message="via direct download" ;;
    esac
    
    # バージョン比較とダウンロード判断
    local status_message="No update needed"
    local update_required=false
    
    if [ "$local_version" = "$dummy_version" ]; then
        update_required=true
    else
        version_is_newer "$remote_version" "$local_version"
        [ $? -eq 0 ] && update_required=true
    fi
    
    debug_log "DEBUG" "Remote version: $file_name - $clean_remote_version"
    debug_log "DEBUG" "Local version: $file_name - $clean_local_version"
    debug_log "DEBUG" "Update required: $file_name -$(printf "%s" "$update_required")"
    
    if [ "$update_required" = "true" ]; then
        # ファイルダウンロード
        if ! $BASE_WGET "$install_path" "$remote_url"; then
            debug_log "ERROR" "Download failed: $file_name is empty"
            return 1
        fi
        
        # ファイル検証
        if [ ! -s "$install_path" ]; then
            debug_log "ERROR" "Download failed: $file_name is empty"
            return 1
        fi
        
        # 権限設定
        if [ "$chmod_mode" = "true" ]; then
            chmod +x "$install_path"
            debug_log "DEBUG" "chmod +x applied to $file_name"
        fi
        
    	# バージョン情報の更新
    	if [ ! -f "$script_file" ]; then
            printf "%s=%s\n" "${file_name}" "${clean_remote_version}" > "$script_file"
    	else
            if grep -q "^${file_name}=" "$script_file"; then
                # エスケープ処理を改良
                escaped_file=$(echo "$file_name" | sed 's/[\/&]/\\&/g')
                escaped_version=$(echo "$clean_remote_version" | sed 's/[\/&]/\\&/g')
                sed -i "s/^${escaped_file}=.*/${escaped_file}=${escaped_version}/" "$script_file"
            else
                printf "%s=%s\n" "${file_name}" "${clean_remote_version}" >> "$script_file"
            fi
        fi
    
        # ステータスメッセージの修正
        status_message="Download completed"
    fi
    
    # 読み込み処理
    local action_message=""
    if [ "$read_mode" = "true" ] || echo "$file_name" | grep -q "common.*\\.sh"; then
        . "$install_path"
        action_message="Loaded"
    fi
    
    # 出力メッセージの修正
    local message="${file_name}: ${status_message} - Version: ${clean_remote_version} ${auth_message}"
    if [ -n "$action_message" ]; then
        message="${message} (${action_message})"
    fi

    # 出力
    if [ "$hidden_mode" = "true" ]; then
        echo -e "$(color green "${message}")"
    else
        debug_log "DEBUG" "Quiet mode ${message}"
    fi
    
    return 0
}

# 🔴　ダウンロード系　ここまで　🔴　-------------------------------------------------------------------------------------------------------------------------------------------

# 🔵　メイン　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------
#########################################################################
# バナー表示
#########################################################################
print_banner() {
    echo
    color magenta "                    ii i"
    color blue    "         aaaa      iii       oooo      sssss"
    color cyan    "            aa      ii      oo  oo    ss"
    color green   "         aaaaa      ii      oo  oo     sssss"
    color yellow  "        aa  aa      ii      oo  oo         ss"
    color red     "         aaaaa     iiii      oooo     ssssss"
    echo
    printf "%s\n" "$(color white "$(get_message "MSG_BANNER_DECCRIPTION")")"
    printf "%s\n" "$(color white "$(get_message "MSG_BANNER_NAME")")"
    printf "%s\n" "$(color red "$(get_message "MSG_BANNER_DISCLAIMER")")"
}

#########################################################################
# パッケージのインストール (オプション)
# テスト用（最終的に推奨パッケージスクリプトに移動）
#########################################################################
packages() {
    # パッケージのインストール
    #install_package luci yn hidden
    install_package ttyd yn hidden
    install_package luci-app-ttyd yn hidden
    install_package luci-i18n-ttyd yn hidden
    install_package openssh-sftp-server yn hidden
    install_package luci-mod-dashboard yn hidden
    #install_package coreutils yn hidden
    install_package irqbalance yn hidden

    feed_package gSpotx2f packages-openwrt current luci-app-cpu-perf yn hidden
    feed_package gSpotx2f packages-openwrt current luci-app-cpu-status yn hidden
    feed_package gSpotx2f packages-openwrt current luci-app-temp-status yn hidden
    feed_package gSpotx2f packages-openwrt current luci-app-log-viewer yn hidden
    feed_package gSpotx2f packages-openwrt current luci-app-log yn hidden
    feed_package gSpotx2f packages-openwrt current internet-detector yn hidden disabled

    feed_package_release lisaac luci-app-diskman yn hidden disabled

    feed_package_release jerrykuku luci-theme-argon yn hidden disabled
    
    # install_package list
}

#########################################################################
# 初期設定
#########################################################################
# 権限設定
chmod_aios() {

    echo "$(color magenta "Setting permissions for $BIN_PATH")"

    if ! chmod +x "$BIN_PATH"; then
        debug_log "ERROR" "Failed to set permissions for $BIN_PATH"
        return 1
    fi
}

# 初期化処理
delete_aios() {
    debug_log "ERROR" "Deleting $BASE_DIR"
    if ! rm -rf "${BASE_DIR}"; then
        debug_log "ERROR" "Failed to delete $BASE_DIR"
        return 1
    fi
}

# 必要ディレクトリ作成
make_directory() {

    echo "$(color magenta "Creating required directories")"

    if ! mkdir -p "${BASE_DIR}" "$CACHE_DIR" "$LOG_DIR" "$FEED_DIR"; then
        debug_log "ERROR" "Failed to create required directories"
        return 1
    fi
}

check_update() {
    # 確実にキャッシュディレクトリが存在するか確認
    mkdir -p "$CACHE_DIR" 2>/dev/null

    # アップデート後の特殊処理
    POST_UPDATE="false"
    if [ -f "${CACHE_DIR}/post_update_flag" ]; then
        POST_UPDATE="true"
        rm -f "${CACHE_DIR}/post_update_flag"
        debug_log "DEBUG" "Post-update detected, continuing with normal execution"
        MODE="full"  # 更新後は標準モードに設定
        return 0
    fi

    # アップデート状態ファイルの確認
    if [ ! -f "$UPDATE_CACHE" ]; then
        # 初回実行: アップデートモードをセット
        debug_log "DEBUG" "First run detected, setting update mode"
        MODE="update"
        # 状態ファイル作成（バージョン情報を記録）
        echo "$SCRIPT_VERSION" > "$UPDATE_CACHE" || debug_log "WARN" "Could not create $UPDATE_CACHE"
    else
        # 再実行: アップデートキャッシュをチェック
        local cached_version=$(cat "$UPDATE_CACHE" 2>/dev/null || echo "unknown")
        if [ "$cached_version" != "$SCRIPT_VERSION" ]; then
            debug_log "DEBUG" "Version changed from $cached_version to $SCRIPT_VERSION"
            # バージョン情報を更新
            echo "$SCRIPT_VERSION" > "$UPDATE_CACHE" || debug_log "WARN" "Could not update $UPDATE_CACHE"
        fi
        # 引数で明示的なモード指定がなければfullをデフォルトに
        [ -z "$MODE" ] && MODE="full"
    fi

    # 常に成功を返す（エラーがあっても処理を継続）
    return 0
}

# 初期化処理を実行
initialization() {
    # 実行権限を設定
    if ! chmod_aios; then
        debug_log "ERROR" "Failed to set execute permission"
        return 1
    fi

    # 必要なディレクトリを作成
    if ! make_directory; then
        debug_log "ERROR" "Failed to create required directories"
        return 1
    fi

    check_update || debug_log "WARN" "Update check had issues, continuing anyway"
    return 0
}

#########################################################################
# Last Update: 2025-02-15 10:00:00 (JST) 🚀
# check_option: コマンドラインオプション解析・正規化関数
#
# 【概要】
# この関数は、aios 起動時に渡されたコマンドライン引数を解析し、
# ダッシュ付きの引数はオプションとして解析、非ダッシュ引数はすべて
# 言語オプションとして扱い、最初に見つかった値を SELECTED_LANGUAGE に設定します。
#
# ※ MODE の指定は必ずダッシュ付きで行い、以下の各パターンを受け付けます。
#     common_full  : -cf, --cf, -common_full, --common_full  → MODE="full"
#     common_light : -cl, --cl, -ocommon_light, --ocommon_light → MODE="light"
#     common_debug : -cd, --cd, -common_debug, --common_debug, --ocommon_debug → MODE="debug"
#     reset        : -r, --r, -reset, --reset, -resrt, --resrt → MODE="reset" および RESET="true"
#
# 【対応オプション】
#  - ヘルプ:         -h, --h, -help, --help, -?, --?  
#  - バージョン:     -v, --v, -version, --version  
#  - デバッグ:       -d, --d, -debug, --debug, -d1, --d1  
#                     → DEBUG_MODE="true", DEBUG_LEVEL="DEBUG"
#                   -d2, --d2, -debug2, --debug2  
#                     → DEBUG_MODE="true", DEBUG_LEVEL="DEBUG2"
#  - モード指定:
#       - full:       -cf, --cf, -common_full, --common_full  → MODE="full"
#       - light:      -cl, --cl, -ocommon_light, --ocommon_light → MODE="light"
#       - debug:      -cd, --cd, -common_debug, --common_debug, --ocommon_debug → MODE="debug"
#       - reset:      -r, --r, -reset, --reset, -resrt, --resrt → MODE="reset", RESET="true"
#  - 強制実行:       -f, --f, -force, --force  → FORCE="true"
#  - ドライラン:     -dr, --dr, -dry-run, --dry-run  → DRY_RUN="true"
#  - ログ出力先:     -l, --l, -logfile, --logfile <path>  → LOGFILE に指定パス
#
# 【仕様】
# 1. ダッシュ付きの引数はオプションとして解析し、非ダッシュ引数はすべて SELECTED_LANGUAGE として扱います。
# 2. 解析結果はグローバル変数 SELECTED_LANGUAGE, DEBUG_MODE, DEBUG_LEVEL, MODE, DRY_RUN, LOGFILE, FORCE, RESET, HELP としてエクスポートされ、
#    後続の check_common(), select_country(), debug(), script_version() などに正規化された値として渡されます。
#
# 【使用例】
#   sh aios.sh -d --dry-run --reset -l /var/log/aios.log -f -cf en
#    → 言語 "en" が SELECTED_LANGUAGE に設定され、MODE は "full"（-cf等で指定）、デバッグモード有効、
#       キャッシュリセット、ドライラン、ログ出力先 /var/log/aios.log、強制実行が有効になる。
#########################################################################
check_option() {

    echo "$(color magenta "check_option received before args: $*")"

    # デフォルト値の設定
    SELECTED_LANGUAGE=""
    DEBUG_MODE="false"
    DEBUG_LEVEL="INFO"
    DRY_RUN="false"
    LOGFILE=""
    FORCE="false"
    RESET="false"
    HELP="false"

    # 言語およびオプション引数の処理
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -h|--h|-help|--help|-\?|--\?)
                HELP="true"
                print_help
                exit 0
                ;;
            -v|--v|-version|--version)
                script_version
                exit 0
                ;;
            -d|--d|-debug|--debug|-d1|--d1)
                DEBUG_MODE="true"
                DEBUG_LEVEL="DEBUG"
                ;;
            -d2|--d2|-debug2|--debug2)
                DEBUG_MODE="true"
                DEBUG_LEVEL="DEBUG2"
                ;;
            -cf|--cf|-common_full|--common_full)
                MODE="full"
                ;;
            -cl|--cl|-ocommon_light|--ocommon_light)
                MODE="light"
                ;;
            -cd|--cd|-common_debug|--common_debug|--ocommon_debug)
                MODE="debug"
                ;;
            -r|--r|-reset|--reset|-resrt|--resrt)
                MODE="reset"
                RESET="true"
                ;;
            -f|--f|-force|--force)
                FORCE="true"
                ;;
            -dr|--dr|-dry-run|--dry-run)
                DRY_RUN="true"
                ;;
            -l|--l|-logfile|--logfile)
                if [ -n "$2" ] && [ "${2#-}" != "$2" ]; then
                    LOGFILE="$2"
                    shift
                else
                    echo "Error: --logfile requires a path argument"
                    exit 1
                fi
                ;;
	    -u|--u|-update|--update)
		debug_log "DEBUG" "check_option: aios update"
    		MODE="update"
    		;;
	    -t|--t|-token|--token)
		setup_github_token
		;;
	    -ts|--ts|--token-status)
    		check_token_status
    		exit 0
    		;;
	    -test_api)
		MODE="test_api"
		;;
            -*)
                echo "Warning: Unknown option: $1" >&2
                ;;
            *)
                if [ -z "$SELECTED_LANGUAGE" ]; then
                    SELECTED_LANGUAGE="$1"
                fi
                ;;
        esac
        shift
    done

    # 環境変数として設定
    export SELECTED_LANGUAGE DEBUG_MODE DEBUG_LEVEL MODE DRY_RUN LOGFILE FORCE RESET HELP

    # デバッグ情報を出力
    debug_log "DEBUG" "check_option: MODE=$MODE, SELECTED_LANGUAGE=$SELECTED_LANGUAGE"
    debug_log "DEBUG" "check_option: DEBUG_MODE=$DEBUG_MODE, DEBUG_LEVEL=$DEBUG_LEVEL"
    debug_log "DEBUG" "check_option: DRY_RUN=$DRY_RUN, LOGFILE=$LOGFILE"
    debug_log "DEBUG" "check_option: FORCE=$FORCE, RESET=$RESET, HELP=$HELP"

    # 設定された言語を `check_common()` に渡す
    check_common "$SELECTED_LANGUAGE" "$MODE"
}

#########################################################################
# Last Update: 2025-02-16 21:45:00 (JST) 🚀
# "Ensuring seamless updates, one script at a time."
#
# 【要件】
# 1. `download_script()` を `download()` に統合し、一貫性を確保する。
# 2. `debug_log()` を強化し、ダウンロード状況を詳細に記録。
# 3. `download()` のエラーハンドリングを見直し、失敗時の挙動を改善。
# 4. `openwrt.db`, `messages.db`, `country.db`, `packages.db` を適切にダウンロード。
# 5. 影響範囲: `common.sh`（矛盾なく適用）。
#########################################################################
check_common() {
    local lang_code="$1"
    local mode="$2"

    debug_log "DEBUG" "check_common: MODE=$MODE"
    debug_log "DEBUG" "check_common: mode=$mode"

    if [ -n "$mode" ]; then
        MODE="$mode"
    fi

    # モードごとの処理
    case "$MODE" in
        reset)
            rm -f "${CACHE_DIR}/country.ch" \
                  "${CACHE_DIR}/language.ch" \
                  "${CACHE_DIR}/luci.ch" \
                  "${CACHE_DIR}/zone.ch" \
                  "${CACHE_DIR}/zonename.ch" \
                  "${CACHE_DIR}/timezone.ch" \
                  "${CACHE_DIR}/country_success_done" \
                  "${CACHE_DIR}/timezone_success_done"
            echo "$(get_message "MSG_RESET_COMPLETE")"
            exit 0
            ;;
        update)
	    download "aios" "hidden" "chmod"
	    if [ ! -f "${CACHE_DIR}/post_update_flag" ]; then
		MODE="full"
		check_common "$lang_code" "$MODE" "$@"
	    else
		MODE="full"
		exec "$BIN_PATH" $(echo "$@" | sed 's/update//g' | sed 's/--update//g' | sed 's/-u//g' | sed 's/--u//g')
	    fi
	    ;;
        debug)
            download "common-country.sh" "hidden"
            download "common-package.sh" "hidden"
            download "common-feed-package.sh" "hidden"
            download "messages.db" "hidden"
            download "openwrt.db" "hidden"
            download "country.db" "hidden"
            download "local-package.db" "hidden"
            download "custom-package.db" "hidden"
            check_openwrt
            check_architecture
            check_downloader
            print_banner
            select_country "$lang_code"
            download "hidden" "system-config.sh" "chmod" "read"
            #packages
            ;;
        light)
            download "common-country.sh"
            download "common-package.sh"
            download "common-feed-package.sh"
            download "messages.db"
            download "openwrt.db"
            download "country.db"
            download "local-package.db"
            download "custom-package.db"
            check_openwrt
            check_architecture
            check_downloader
            print_banner
            select_country "$lang_code"
            download "hidden" "system-config.sh" "chmod" "read"
            #packages
            ;;
        full)
            download "common-country.sh"
            download "common-package.sh"
            download "common-feed-package.sh"
            download "messages.db"
            download "openwrt.db"
            download "country.db"
            download "local-package.db"
            download "custom-package.db"
            check_openwrt
            check_architecture
            check_downloader
            print_banner
            select_country "$lang_code"
            download "system-config.sh" "chmod" "read"
            #packages
            ;;
        return)
            rm -f "${CACHE_DIR}/country.ch" \
                  "${CACHE_DIR}/language.ch" \
                  "${CACHE_DIR}/luci.ch" \
                  "${CACHE_DIR}/zone.ch" \
                  "${CACHE_DIR}/zonename.ch" \
                  "${CACHE_DIR}/timezone.ch" \
                  "${CACHE_DIR}/country_success_done" \
                  "${CACHE_DIR}/timezone_success_done"
            select_country
            ;;
	test_api)
	    #wget -q -O /tmp/aios/github_api_test.sh "https://raw.githubusercontent.com/site-u2023/aios/main/github_api_test.sh"
	    BASE_WGET ${BASE_DIR}/github_api_test.sh ${BASE_URL}/github_api_test.sh
	    chmod +x ${BASE_DIR}/github_api_test.sh
	    sh ${BASE_DIR}/github_api_test.sh
	    ;;
        *)
            ;;
    esac
}

# メイン処理
main() {
    initialization
    check_option "$@"
}

# 🔴　メイン　ここまで　🔴　-------------------------------------------------------------------------------------------------------------------------------------------

# スクリプト実行
main "$@"
