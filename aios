#!/bin/sh

SCRIPT_VERSION="2025.04.22-00-00"

# =========================================================
# 📌 OpenWrt / Alpine Linux POSIX-Compliant Shell Script
# 🚀 Last Update: 2025-02-21
#
# 🏷️ License: CC0 (Public Domain)
# 🎯 Compatibility: OpenWrt >= 19.07 (Tested on 24.10.0)
#
# ⚠️ IMPORTANT NOTICE:
# OpenWrt OS exclusively uses **Almquist Shell (ash)** and
# is **NOT** compatible with Bourne-Again Shell (bash).
#
# 📢 POSIX Compliance Guidelines:
# ✅ Use `[` instead of `[[` for conditions
# ✅ Use $(command) instead of backticks `command`
# ✅ Use $(( )) for arithmetic instead of let
# ✅ Define functions as func_name() {} (no function keyword)
# ✅ No associative arrays (declare -A is NOT supported)
# ✅ No here-strings (<<< is NOT supported)
# ✅ No -v flag in test or [[
# ✅ Avoid bash-specific string operations like ${var:0:3}
# ✅ Avoid arrays entirely when possible (even indexed arrays can be problematic)
# ✅ Use printf followed by read instead of read -p
# ✅ Use printf instead of echo -e for portable formatting
# ✅ Avoid process substitution <() and >()
# ✅ Prefer case statements over complex if/elif chains
# ✅ Use command -v instead of which or type for command existence checks
# ✅ Keep scripts modular with small, focused functions
# ✅ Use simple error handling instead of complex traps
# ✅ Test scripts with ash/dash explicitly, not just bash
#
# 🛠️ Keep it simple, POSIX-compliant, and lightweight for OpenWrt!
### =========================================================
### 📌 AI Assistance Request: POSIX-Compliant Debugging Guide
### 
### When debugging or fixing errors in this POSIX shell script:
### 
### 1️⃣ Create a minimal reproducible test case (avoid bash features)
### 2️⃣ Test with ash/dash explicitly: dash ./test.sh
### 3️⃣ Use portable debugging methods: echo, printf, or set -x
### 4️⃣ Validate fixes against all POSIX compliance guidelines
### 5️⃣ Ensure the solution works in resource-constrained OpenWrt
### 
### ⚠️ IMPORTANT:
### - Avoid suggesting bash-specific solutions
### - Always test fixes with ash/dash before implementation
### - Prefer simple solutions over complex ones
### - Do not modify production code without test verification
### 
### 🛠️ Keep debugging simple, focused, and POSIX-compliant!
### =========================================================

# システム制御
DEV_NULL="${DEV_NULL:-on}"       # サイレントモード制御（on=有効, unset=無効）
DEBUG_MODE="${DEBUG_MODE:-false}" # デバッグモード（true=有効, false=無効）
DOWNLOAD_METHOD="${DOWNLOAD_METHOD:-api}" # ダウンロード方式 (api/direct)
# DOWNLOAD_METHOD="${DOWNLOAD_METHOD:-direct}" # ダウンロード方式 (api/direct)

# パス・ファイル関連
INTERPRETER="${INTERPRETER:-ash}"  # デフォルトインタープリタ
BIN_PATH="$(readlink -f "$0")"   # 実行ファイルの絶対パス
BIN_DIR="$(dirname "$BIN_PATH")" # 実行ファイルのディレクトリ
BIN_FILE="$(basename "$BIN_PATH")" # 実行ファイル名

# ベースディレクトリ設定
BASE_DIR="${BASE_DIR:-/tmp/aios}"      # 基本ディレクトリ
CACHE_DIR="${CACHE_DIR:-$BASE_DIR/cache}" # キャッシュディレクトリ
FEED_DIR="${FEED_DIR:-$BASE_DIR/feed}" # フィードディレクトリ
LOG_DIR="${LOG_DIR:-$BASE_DIR/logs}"   # ログディレクトリ

# ダウンロード関連設定
BASE_URL="${BASE_URL:-https://raw.githubusercontent.com/site-u2023/aios/main}" # 基本URL
CACHE_BUST="?cache_bust=$(date +%s)" # キャッシュバスティングパラメータ

# wget関連設定
BASE_WGET="wget --no-check-certificate -q" # 基本wgetコマンド
BASE_WGET_AUTH_BEARER='wget --no-check-certificate -q -O "$1" --header="Authorization: Bearer $2" "$3"' # Bearer認証用
BASE_WGET_AUTH_TOKEN='wget --no-check-certificate -q -O "$1" --header="Authorization: token $2" "$3"'   # Token認証用

# GitHub API認証関連
GITHUB_TOKEN_FILE="/etc/aios_token" # GitHubトークン保存ファイル
UPDATE_CACHE="${CACHE_DIR}/update.ch" # 更新情報キャッシュ

# メッセージ翻訳システムの設定
DEFAULT_LANGUAGE="${DEFAULT_LANGUAGE:-en}"  # デフォルト言語
MSG_MEMORY=""                          # メッセージキャッシュ
MSG_MEMORY_INITIALIZED="false"         # メモリキャッシュ初期化フラグ
MSG_MEMORY_LANG=""                     # メモリキャッシュの言語

# String Formatting Control within get_message function
GET_MESSAGE_FORMATTING_ENABLED="true"   # get_message 内でのフォーマット処理全体を有効にするか (true/false)
FORMAT_TYPE_UPPER_ENABLED="true"        # 'upper' (大文字) フォーマットを有効にするか (true/false)
FORMAT_TYPE_CAPITALIZE_ENABLED="true"   # 'capitalize' (先頭大文字) フォーマットを有効にするか (true/false)

# メッセージキャッシュ
MSG_MEMORY=""
MSG_MEMORY_INITIALIZED="false"
MSG_MEMORY_LANG=""

# GitHub APIレート制限情報
API_REMAINING=""       # 残りAPI呼び出し回数
API_LIMIT=""           # APIレート制限値
API_RESET_TIME=""      # API制限リセット時間（分）
API_AUTH_METHOD=""     # 認証方法（token/bearer/direct）
API_LAST_CHECK=""      # 最終API確認時間（Unix時間）
API_CACHE_TTL="60"     # APIキャッシュ有効期間（秒）

# コミット情報キャッシュ関連
COMMIT_CACHE_DIR="${CACHE_DIR}/commits" # コミット情報キャッシュディレクトリ
COMMIT_CACHE_TTL="1800" # コミットキャッシュ有効期間（30分=1800秒）
SKIP_CACHE="false"     # キャッシュスキップフラグ（true=キャッシュ無視）

# 🔵　エラー・デバッグ　ここから　🔵-------------------------------------------------------------------------------------------------------------------------------------------

handle_error() {
    local error_key="$1"
    local file="$2"
    local version="$3"
    local exit_required="${4:-no}"

    local error_message
    error_message=$(get_message "$error_key")

    # メッセージが取得できなかった場合のフォールバック
    if [ -z "$error_message" ]; then
        error_message="Unknown error occurred. Key: $error_key"
    fi

    # 変数を置換
    error_message=$(echo "$error_message" | sed -e "s/{file}/$file/g" -e "s/{version}/$version/g")

    # ログ記録 & 表示
    debug_log "DEBUG" "$error_message"
    echo -e "$(color red "$error_message")"

    if [ "$exit_required" = "yes" ]; then
        debug_log "DEBUG" "Critical error occurred, exiting: $error_message"
        exit 1
    else
        debug_log "DEBUG" "Non-critical error: $error_message"
        return 1
    fi
}

debug_log() {
    local level="$1"
    local message="$2"
    local file="$3"
    local version="$4"
    local debug_level="${DEBUG_LEVEL:-ERROR}"  # デフォルト値を設定
    
    # レベル判定のシンプル化
    case "$level" in
        "DEBUG"|"INFO"|"WARN"|"ERROR") ;;
        "")
            level="DEBUG"
            message="$1"
            file="$2"
            version="$3"
            ;;
        *)
            message="$1"
            file="$2"
            version="$3"
            level="DEBUG"
            ;;
    esac

    # バージョン情報のクリーニング（メッセージにバージョン情報が含まれる場合）
    if echo "$message" | grep -q "version\|Version"; then
        # バージョン情報部分を抽出してクリーニング
        local cleaned_message="$message"
        # aios - [2025-03-10... のようなパターンを検出
        if echo "$message" | grep -q " - "; then
            local prefix=$(echo "$message" | sed 's/ - .*//')
            local version_part=$(echo "$message" | sed 's/.* - //')
            
            # clean_version_string関数を呼び出し
            local cleaned_version=$(clean_version_string "$version_part")
            
            cleaned_message="$prefix - $cleaned_version"
        fi
        message="$cleaned_message"
    fi

    # 変数を置換
    message=$(echo "$message" | sed -e "s/{file}/$file/g" -e "s/{version}/$version/g")

    # ログレベル制御
    case "$DEBUG_LEVEL" in
        DEBUG)    allowed_levels="DEBUG INFO WARN ERROR" ;;
        INFO)     allowed_levels="INFO WARN ERROR" ;;
        WARN)     allowed_levels="WARN ERROR" ;;
        ERROR)    allowed_levels="ERROR" ;;
        *)        allowed_levels="ERROR" ;;
    esac

    if echo "$allowed_levels" | grep -q "$level"; then
        local timestamp
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        local log_message="[$timestamp] $level: $message"

        # カラー表示 - 標準エラー出力に出力
        case "$level" in
            "ERROR") printf "%s\n" "$(color red "$log_message")" >&2 ;;
            "WARN") printf "%s\n" "$(color yellow "$log_message")" >&2 ;;
            "INFO") printf "%s\n" "$(color cyan "$log_message")" >&2 ;;
            "DEBUG") printf "%s\n" "$(color white "$log_message")" >&2 ;;
        esac

        # ログファイルに記録
        if [ "$AIOS_INITIALIZED" = "true" ] && [ -d "$LOG_DIR" ]; then
            echo "$log_message" >> "$LOG_DIR/debug.log" 2>/dev/null
        fi
    fi
}

# 🔴　エラー・デバッグ　ここまで　🔴-------------------------------------------------------------------------------------------------------------------------------------------

# 🔵　ヘルプ　ここから　🔵-------------------------------------------------------------------------------------------------------------------------------------------

print_help() {
    printf "%s\n\n" "$(get_message "MSG_HELP_USAGE")"
    
    printf "%s\n" "$(get_message "MSG_HELP_OPTIONS_HEADER")"
    printf "  %-25s %s\n" "-h, --help" "$(get_message "MSG_HELP_HELP")"
    printf "  %-25s %s\n" "-v, --version" "$(get_message "MSG_HELP_VERSION")"
    printf "  %-25s %s\n" "-r, --reset" "$(get_message "MSG_HELP_RESET")"
    printf "  %-25s %s\n" "-d, --debug" "$(get_message "MSG_HELP_DEBUG")"
    printf "  %-25s %s\n" "-u, --update" "$(get_message "MSG_HELP_UPDATE")"
    printf "  %-25s %s\n" "-f, --force" "$(get_message "MSG_HELP_FORCE")"
    printf "  %-25s %s\n" "-t, --token" "$(get_message "MSG_HELP_TOKEN")"
    printf "  %-25s %s\n" "-cf, --common_full" "$(get_message "MSG_HELP_FULL")"
    printf "  %-25s %s\n" "-cl, --common_light" "$(get_message "MSG_HELP_LIGHT")"
    printf "  %-25s %s\n" "-cd, --common_debug" "$(get_message "MSG_HELP_COMMON_DEBUG")"
    printf "  %-25s %s\n" "-dr, --dry-run" "$(get_message "MSG_HELP_DRY_RUN")"
    printf "  %-25s %s\n" "-nc, --no-cache" "Skip using cached version data"
    
    printf "\n%s\n" "$(get_message "MSG_HELP_LANGUAGE_HEADER")"
    printf "  %-25s %s\n" "US, JP, ..." "$(get_message "MSG_HELP_LANGUAGE")"
    
    printf "\n%s\n" "$(get_message "MSG_HELP_EXAMPLES_HEADER")"
    printf "  %s\n" "$(get_message "MSG_HELP_EXAMPLE1")"
    printf "  %s\n" "$(get_message "MSG_HELP_EXAMPLE2")"
    printf "  %s\n" "$(get_message "MSG_HELP_EXAMPLE3")"
    printf "  %s\n" "$(get_message "MSG_HELP_EXAMPLE4")"
}

# 🔴　ヘルプ　ここまで　🔴-------------------------------------------------------------------------------------------------------------------------------------------

# 🔵　カラー系　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------

# 基本色表示関数
color() {
    local c="$1"; shift
    case "$c" in
        red) printf "\033[38;5;196m%s\033[0m" "$*" ;;
        orange) printf "\033[38;5;208m%s\033[0m" "$*" ;;
        yellow) printf "\033[38;5;226m%s\033[0m" "$*" ;;
        green) printf "\033[38;5;46m%s\033[0m" "$*" ;;
        cyan) printf "\033[38;5;51m%s\033[0m" "$*" ;;
        blue) printf "\033[38;5;33m%s\033[0m" "$*" ;;
        indigo) printf "\033[38;5;57m%s\033[0m" "$*" ;;
        purple) printf "\033[38;5;129m%s\033[0m" "$*" ;;
        magenta) printf "\033[38;5;201m%s\033[0m" "$*" ;;
        white) printf "\033[37m%s\033[0m" "$*" ;;
        black) printf "\033[30m%s\033[0m" "$*" ;;
        *) printf "%s" "$*" ;;
    esac
}

# 🔴　カラー系　ここまで　🔴-------------------------------------------------------------------------------------------------------------------------------------------

# 🔵　メッセージ系　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------

# メモリへのメッセージ読み込み関数
into_memory_message() {
    local lang="$DEFAULT_LANGUAGE"
    if [ -f "${CACHE_DIR}/message.ch" ]; then
        lang=$(cat "${CACHE_DIR}/message.ch")
    fi
    
    # メモリメッセージの初期化 - 基本的な補助メッセージのみを保持
    MSG_MEMORY=""
    
    # 基本メッセージの設定
    MSG_MEMORY="${MSG_MEMORY}${lang}|CONFIG_DOWNLOAD_SUCCESS=Downloaded{:}"$'\n'
    MSG_MEMORY="${MSG_MEMORY}${lang}|CONFIG_DOWNLOAD_UNNECESSARY=Latest Files{:}"$'\n'
    MSG_MEMORY="${MSG_MEMORY}${lang}|MSG_RESET_COMPLETE=Reset completed. All cached data has been cleared"$'\n'
    MSG_MEMORY="${MSG_MEMORY}${lang}|MSG_DELETE_COMPLETE=Delete completed. All base data has been cleared"$'\n'
    
    # DBファイルの内容を追加しない - DBファイルが主要ソース
    
    MSG_MEMORY_INITIALIZED="true"
    MSG_MEMORY_LANG="$lang"
}

# 翻訳システムを初期化する関数
init_translation() {
    debug_log "DEBUG" "Initializing translation system"
    
    # message.chが無い場合、デフォルト言語を設定
    if [ ! -f "${CACHE_DIR}/message.ch" ] && [ -f "${BASE_DIR}/message_${DEFAULT_LANGUAGE}.db" ]; then
        echo "$DEFAULT_LANGUAGE" > "${CACHE_DIR}/message.ch"
        debug_log "DEBUG" "Created default language settings: $DEFAULT_LANGUAGE"
    fi
    
    # メモリ内メッセージの初期化
    into_memory_message
    
    debug_log "DEBUG" "Translation module initialization complete"
    return 0
}

# メッセージDBファイルのパスを取得する関数
check_message_cache() {
    local lang="$1"
    
    # 言語パラメータの確認
    if [ -z "$lang" ]; then
        # 言語が指定されていない場合、message.chから取得
        if [ -f "${CACHE_DIR}/message.ch" ]; then
            lang=$(cat "${CACHE_DIR}/message.ch")
        else
            lang="$DEFAULT_LANGUAGE"
        fi
    fi
    
    # 言語固有DBの確認
    if [ -f "${BASE_DIR}/message_${lang}.db" ]; then
        echo "${BASE_DIR}/message_${lang}.db"
        return 0
    fi
    
    # デフォルト言語DBの確認
    if [ -f "${BASE_DIR}/message_${DEFAULT_LANGUAGE}.db" ]; then
        echo "${BASE_DIR}/message_${DEFAULT_LANGUAGE}.db"
        return 0
    fi
    
    # 何も見つからない場合は空文字列
    echo ""
    return 0
}

# Function to format strings based on specified type
# Usage: format_string <format_type> <input_string>
# format_type: "upper" (all uppercase), "capitalize" (first letter uppercase, rest lowercase)
# Default: returns original string if type is unknown or empty
format_string() {
    local format_type="$1"
    local input_string="$2"
    local output_string=""

    # Check if input string is empty
    if [ -z "$input_string" ]; then
        echo ""
        return 0
    fi

    case "$format_type" in
        "upper")
            # Convert entire string to uppercase using sed
            debug_log "DEBUG" "format_string: Formatting to uppercase"
            output_string=$(echo "$input_string" | sed \
                -e 's/a/A/g' -e 's/b/B/g' -e 's/c/C/g' -e 's/d/D/g' -e 's/e/E/g' \
                -e 's/f/F/g' -e 's/g/G/g' -e 's/h/H/g' -e 's/i/I/g' -e 's/j/J/g' \
                -e 's/k/K/g' -e 's/l/L/g' -e 's/m/M/g' -e 's/n/N/g' -e 's/o/O/g' \
                -e 's/p/P/g' -e 's/q/Q/g' -e 's/r/R/g' -e 's/s/S/g' -e 's/t/T/g' \
                -e 's/u/U/g' -e 's/v/V/g' -e 's/w/W/g' -e 's/x/X/g' -e 's/y/Y/g' \
                -e 's/z/Z/g')
            ;;
        "capitalize")
            # Convert first letter to uppercase, rest to lowercase
            debug_log "DEBUG" "format_string: Formatting to capitalize"
            # Extract first character
            local first_char=$(echo "$input_string" | cut -c1)
            # Extract rest of the string
            local rest_string=$(echo "$input_string" | cut -c2-)

            # Convert first char to uppercase
            local first_char_upper=$(echo "$first_char" | tr '[:lower:]' '[:upper:]')
            # Convert rest of the string to lowercase
            local rest_string_lower=$(echo "$rest_string" | tr '[:upper:]' '[:lower:]')

            # Combine them
            output_string="${first_char_upper}${rest_string_lower}"
            ;;
        *)
            # Unknown or empty format type, return original string
            debug_log "DEBUG" "format_string: Unknown format type '$format_type', returning original string"
            output_string="$input_string"
            ;;
    esac

    # Return the formatted string
    printf '%s' "$output_string"
    return 0
}

normalize_message() {
    local input="$1"
    local lang="$2"
    local output="$input"
    local saved_locale="$LC_ALL"

    debug_log "DEBUG" "normalize_message: Input = [$input]"

    # Full-width to half-width normalization
    output=$(echo "$output" | sed 's/｛/{/g; s/｝/}/g')
    output=$(echo "$output" | sed 's/：/:/g; s/∶/:/g; s/꞉/:/g; s/ː/:/g')
    output=$(echo "$output" | sed 's/；/;/g')
    output=$(echo "$output" | sed 's/　/ /g')
    output=$(echo "$output" | sed 's/＠/@/g')
    output=$(echo "$output" | sed 's/＼/\\/g')
    debug_log "DEBUG" "normalize_message: After full-width normalization = [$output]"

    # Placeholder space removal (using LC_ALL=C for safety)
    LC_ALL=C
    debug_log "DEBUG" "normalize_message: Entering LC_ALL=C block for space removal"
    local before_space_removal="$output"
    output=$(echo "$output" | sed 's/[[:space:]]\+{/{/g') # Space before {
    # output=$(echo "$output" | sed 's/}[[:space:]]\+/}/g') # Space after }
    output=$(echo "$output" | sed 's/{[[:space:]]\+/{/g') # Space after { (inside)
    output=$(echo "$output" | sed 's/[[:space:]]\+}/}/g') # Space before } (inside)
    if [ "$output" != "$before_space_removal" ]; then
        debug_log "DEBUG" "normalize_message: Placeholder space removal applied. Result = [$output]"
    fi
    debug_log "DEBUG" "normalize_message: Exiting LC_ALL=C block. Result = [$output]"
    LC_ALL="$saved_locale"

    # Special placeholder replacement ( {;} is NOT replaced here )
    local before_special_replace="$output"
    output=$(echo "$output" | sed 's/{:}/:/g') # {:} -> :
    if [ "$output" != "$before_special_replace" ]; then
         debug_log "DEBUG" "normalize_message: Replaced {:} with :. Result = [$output]"
    fi
    before_special_replace="$output"
    output=$(echo "$output" | sed 's/{@}/\\n/g') # {@} -> newline (\n)
     if [ "$output" != "$before_special_replace" ]; then
         debug_log "DEBUG" "normalize_message: Replaced {@} with \\n. Result = [$output]"
    fi

    # Language-specific number normalization
    local before_num_norm="$output"
    case "${lang%%-*}" in
        ar) output=$(echo "$output" | sed 's/٠/0/g; s/١/1/g; s/٢/2/g; s/٣/3/g; s/٤/4/g; s/٥/5/g; s/٦/6/g; s/٧/7/g; s/٨/8/g; s/٩/9/g') ;;
        fa) output=$(echo "$output" | sed 's/۰/0/g; s/۱/1/g; s/۲/2/g; s/۳/3/g; s/۴/4/g; s/۵/5/g; s/۶/6/g; s/۷/7/g; s/۸/8/g; s/۹/9/g') ;;
        bn) output=$(echo "$output" | sed 's/০/0/g; s/۱/1/g; s/২/2/g; s/৩/3/g; s/৪/4/g; s/৫/5/g; s/৬/6/g; s/৭/7/g; s/৮/8/g; s/৯/9/g') ;;
        hi|mr|ne) output=$(echo "$output" | sed 's/०/0/g; s/१/1/g; s/२/2/g; s/३/3/g; s/४/4/g; s/५/5/g; s/६/6/g; s/७/7/g; s/८/8/g; s/९/9/g') ;;
        ja|zh|ko) output=$(echo "$output" | sed 's/０/0/g; s/１/1/g; s/２/2/g; s/３/3/g; s/４/4/g; s/５/5/g; s/６/6/g; s/７/7/g; s/８/8/g; s/９/9/g') ;;
    esac

    # Consolidated log output for number normalization
    if [ "$output" != "$before_num_norm" ]; then
        debug_log "DEBUG" "normalize_message: Applied number normalization for '$lang'. Result = [$output]"
    fi

    debug_log "DEBUG" "normalize_message: Final Output = [$output]"
    printf '%s' "$output" # 出力は %s のまま
    return 0
}

# メッセージを取得し、パラメータ置換とフォーマットを行う関数
# Usage: get_message <key> [format_type] [param1=value1] [param2=value2] ...
# format_type: "upper", "capitalize", "none" (default)
# Reads global variables: GET_MESSAGE_FORMATTING_ENABLED, FORMAT_TYPE_UPPER_ENABLED, FORMAT_TYPE_CAPITALIZE_ENABLED
get_message() {
    local key="$1"
    local format_type="none" # デフォルトのフォーマットタイプ
    local shift_count=1      # デフォルトはキーのみを shift する

    # 第2引数が存在し、かつそれがフォーマットタイプ指定子であるか確認
    if [ $# -ge 2 ]; then
        case "$2" in
            upper|capitalize|none)
                format_type="$2"
                shift_count=2
                debug_log "DEBUG" "get_message: Format type '$format_type' provided for key '$key'."
                ;;
            *)
                debug_log "DEBUG" "get_message: Second argument '$2' is not a format type, assuming parameter for key '$key'."
                ;;
        esac
    else
        debug_log "DEBUG" "get_message: No second argument provided for key '$key'."
    fi

    # 判定結果に基づいて shift を実行
    shift "$shift_count"

    local lang="$DEFAULT_LANGUAGE"
    local message=""
    local add_colon="false"

    # 言語コードの取得
    if [ -f "${CACHE_DIR}/message.ch" ]; then
        lang=$(cat "${CACHE_DIR}/message.ch")
    fi

    # 1. DBからメッセージ取得
    local db_file="$(check_message_cache "$lang")"
    if [ -n "$db_file" ] && [ -f "$db_file" ]; then
        message=$(grep "^${lang}|${key}=" "$db_file" 2>/dev/null | cut -d'=' -f2-)
        if [ -z "$message" ] && [ "$lang" != "$DEFAULT_LANGUAGE" ]; then
            local default_db_file="$(check_message_cache "$DEFAULT_LANGUAGE")"
            if [ -n "$default_db_file" ] && [ -f "$default_db_file" ]; then
                message=$(grep "^${DEFAULT_LANGUAGE}|${key}=" "$default_db_file" 2>/dev/null | cut -d'=' -f2-)
            fi
        fi
    fi

    # 2. メモリキャッシュを試す
    if [ -z "$message" ]; then
        if [ "$MSG_MEMORY_INITIALIZED" != "true" ] || [ "$MSG_MEMORY_LANG" != "$lang" ]; then
            into_memory_message
        fi
        if [ -n "$MSG_MEMORY" ]; then
            message=$(echo "$MSG_MEMORY" | grep "^${lang}|${key}=" 2>/dev/null | cut -d'=' -f2-)
            if [ -z "$message" ] && [ "$lang" != "$DEFAULT_LANGUAGE" ]; then
                 message=$(echo "$MSG_MEMORY" | grep "^${DEFAULT_LANGUAGE}|${key}=" 2>/dev/null | cut -d'=' -f2-)
            fi
        fi
    fi

    # 3. フォールバック
    if [ -z "$message" ]; then
        message="$key"
    fi

    # 4. {;} 検出
    if echo "$message" | grep -q '{;}'; then
        message=$(echo "$message" | sed 's/{;}//g')
        add_colon="true"
    fi

    # 5. パラメータ置換 ($@ は shift 済み)
    for param in "$@"; do
        param_name=$(echo "$param" | cut -d'=' -f1)
        param_value=$(echo "$param" | cut -d'=' -f2-)
        local escaped_value=$(printf '%s\n' "$param_value" | sed -e 's/[\\#]/\\&/g')
        if [ -n "$param_name" ] ; then
             message=$(echo "$message" | sed "s#{$param_name}#$escaped_value#g")
             debug_log "DEBUG" "get_message: Replaced {$param_name} for key '$key'"
        fi
    done

    # 6. normalize_message
    message=$(normalize_message "$message" "$lang")

    # --- 変更箇所 ここから ---
    # 7. フォーマット処理 (グローバル変数による制御付き)
    if [ "$GET_MESSAGE_FORMATTING_ENABLED" = "true" ]; then
        # フォーマット処理が全体的に有効な場合のみ実行
        case "$format_type" in
            "upper")
                # 'upper' タイプが有効かチェック
                if [ "$FORMAT_TYPE_UPPER_ENABLED" = "true" ]; then
                    debug_log "DEBUG" "get_message: Applying 'upper' format (enabled) for key '$key'"
                    message=$(format_string "upper" "$message")
                else
                    debug_log "DEBUG" "get_message: 'upper' format is disabled (FORMAT_TYPE_UPPER_ENABLED=false) for key '$key'"
                fi
                ;;
            "capitalize")
                # 'capitalize' タイプが有効かチェック
                if [ "$FORMAT_TYPE_CAPITALIZE_ENABLED" = "true" ]; then
                    debug_log "DEBUG" "get_message: Applying 'capitalize' format (enabled) for key '$key'"
                    message=$(format_string "capitalize" "$message")
                else
                    debug_log "DEBUG" "get_message: 'capitalize' format is disabled (FORMAT_TYPE_CAPITALIZE_ENABLED=false) for key '$key'"
                fi
                ;;
            "none"|*)
                # "none" または未知のタイプの場合は何もしない
                debug_log "DEBUG" "get_message: No formatting applied (type: '$format_type') for key '$key'"
                ;;
        esac
    else
        # フォーマット処理が全体的に無効な場合
        debug_log "DEBUG" "get_message: Formatting globally disabled (GET_MESSAGE_FORMATTING_ENABLED=false) for key '$key'"
    fi
    # --- 変更箇所 ここまで ---

    # 8. コロン追加
    if [ "$add_colon" = "true" ]; then message="${message}: "; fi

    # 9. 出力
    printf "%b" "$message"
    return 0
}

# 🔴　メッセージ系　ここまで　🔴-------------------------------------------------------------------------------------------------------------------------------------------

# 🔵　トークン系　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------

# コミット情報をキャッシュに保存する関数
save_commit_to_cache() {
    local file_path="$1"
    local version="$2"
    local auth_method="$3"
    local cache_file="${COMMIT_CACHE_DIR}/$(echo "$file_path" | tr '/' '_').commit"
    local timestamp=$(date +%s)
    
    debug_log "DEBUG" "Saving commit info to cache: $file_path -> $cache_file"
    
    # キャッシュフォルダがなければ作成
    [ -d "${COMMIT_CACHE_DIR}" ] || mkdir -p "${COMMIT_CACHE_DIR}"
    
    # キャッシュファイルに情報を書き込み
    {
        echo "VERSION=$version"
        echo "AUTH_METHOD=$auth_method"
        echo "TIMESTAMP=$timestamp"
        echo "TTL=$COMMIT_CACHE_TTL"
        echo "FILE_PATH=$file_path"
    } > "$cache_file"
    
    return 0
}

# キャッシュからコミット情報を取得する関数
get_commit_from_cache() {
    local file_path="$1"
    local force="$2"  # キャッシュ強制無視フラグ
    local cache_file="${COMMIT_CACHE_DIR}/$(echo "$file_path" | tr '/' '_').commit"
    local current_time=$(date +%s)
    
    # キャッシュスキップが有効またはforceフラグが指定されている場合はキャッシュを無視
    if [ "$SKIP_CACHE" = "true" ] || [ "$force" = "true" ] || [ "$FORCE" = "true" ]; then
        debug_log "DEBUG" "Skipping cache for $file_path (forced)"
        return 1
    fi
    
    # キャッシュファイルが存在しない場合
    if [ ! -f "$cache_file" ]; then
        debug_log "DEBUG" "No cache found for $file_path"
        return 1
    fi
    
    # キャッシュファイルから情報を読み込む
    . "$cache_file"
    
    # 必須変数が設定されているか確認
    if [ -z "$VERSION" ] || [ -z "$TIMESTAMP" ] || [ -z "$TTL" ]; then
        debug_log "DEBUG" "Invalid cache file for $file_path"
        return 1
    fi
    
    # キャッシュが有効期限内かチェック
    if [ $(( current_time - TIMESTAMP )) -gt "$TTL" ]; then
        debug_log "DEBUG" "Cache expired for $file_path ($(( (current_time - TIMESTAMP) / 60 )) minutes old)"
        return 1
    fi
    
    # キャッシュが有効な場合は結果を返す
    debug_log "DEBUG" "Using cached commit info for $file_path: $VERSION (age: $(( (current_time - TIMESTAMP) / 60 )) minutes)"
    echo "$VERSION $AUTH_METHOD"
    return 0
}

format_api_status() {
    local auth_method="$1"
    local remaining="$2"
    local limit="$3"
    local reset_minutes="$4"
    local status_text=""
    
    debug_log "DEBUG" "Formatting API status with auth_method=$auth_method, remaining=$remaining, limit=$limit, reset_minutes=$reset_minutes"
    
    if [ "$auth_method" = "token" ] || [ "$auth_method" = "header" ] || [ "$auth_method" = "user" ]; then
        # 認証API表示
        status_text="API: ${remaining}/${limit} TTL:${reset_minutes}m"
    elif [ "$auth_method" = "direct" ] && [ -n "$remaining" ] && [ -n "$limit" ]; then
        # 未認証APIでも残り回数が分かる場合
        status_text="API: ${remaining}/${limit} TTL:${reset_minutes}m"
    else
        # 直接ダウンロード時
        status_text="API: N/A TTL:${reset_minutes}m"
    fi
    
    echo "$status_text"
}

github_api_request() {
    local endpoint="$1"
    local token=$(get_github_token)
    local response=""
    local auth_method="direct"
    local temp_file="${CACHE_DIR}/api_request.tmp"
    local retry_count=0
    local max_retries=2
    
    # 関数内でのwgetコマンド用のローカル変数を定義
    local local_wget_ipv_opt="$WGET_IPV_OPT"
    local local_base_wget="$BASE_WGET"
    local local_base_wget_auth_bearer="$BASE_WGET_AUTH_BEARER"
    local local_base_wget_auth_token="$BASE_WGET_AUTH_TOKEN"
    
    # wgetの機能チェック
    if [ -z "$WGET_SUPPORTS_HEADER" ]; then
        if wget --help 2>&1 | grep -q -- "--header"; then
            export WGET_SUPPORTS_HEADER=1
        else
            export WGET_SUPPORTS_HEADER=0
        fi
    fi
    
    # GitHub API呼び出しを試行（リトライロジック付き）
    while [ $retry_count -le $max_retries ]; do
        if [ $retry_count -gt 0 ]; then
            debug_log "DEBUG" "Retry attempt $retry_count for API request: $endpoint"
            sleep 1  # リトライ間隔
        fi
        
        if [ -n "$token" ]; then
            debug_log "DEBUG" "Using token authentication for API request"
            
            # 認証方法1: Bearerヘッダー認証
            if [ "$WGET_SUPPORTS_HEADER" = "1" ]; then
                debug_log "DEBUG" "Trying Bearer authentication"
                
                # ローカル変数のBearer認証設定を使用
                eval $local_base_wget_auth_bearer "$temp_file" "$token" "https://api.github.com/$endpoint" 2>/dev/null
                
                if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
                    response=$(cat "$temp_file")
                    if ! echo "$response" | grep -q '"message":"Bad credentials"'; then
                        auth_method="bearer"
                        debug_log "DEBUG" "Bearer authentication successful"
                        break  # 成功したらループを抜ける
                    else
                        debug_log "DEBUG" "Bearer authentication failed, trying token auth"
                        
                        # ローカル変数のToken認証設定を使用
                        eval $local_base_wget_auth_token "$temp_file" "$token" "https://api.github.com/$endpoint" 2>/dev/null
                        
                        if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
                            response=$(cat "$temp_file")
                            if ! echo "$response" | grep -q '"message":"Bad credentials"'; then
                                auth_method="token"
                                debug_log "DEBUG" "Token authentication successful"
                                break  # 成功したらループを抜ける
                            else
                                debug_log "DEBUG" "Token authentication failed"
                            fi
                        fi
                    fi
                else
                    debug_log "DEBUG" "Empty response from Bearer authentication"
                fi
            fi
            
            # 認証方法2: wgetのユーザー認証（ヘッダーがサポートされていない場合）
            if [ "$auth_method" = "direct" ] && [ "$WGET_SUPPORTS_HEADER" = "0" ]; then
                debug_log "DEBUG" "Trying user authentication"
                $local_base_wget -O "$temp_file" --user="$token" --password="x-oauth-basic" \
                         "https://api.github.com/$endpoint" 2>/dev/null
                         
                if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
                    response=$(cat "$temp_file")
                    if ! echo "$response" | grep -q '"message":"Bad credentials"'; then
                        auth_method="user"
                        debug_log "DEBUG" "User authentication successful"
                        break  # 成功したらループを抜ける
                    else
                        debug_log "DEBUG" "User authentication failed"
                    fi
                fi
            fi
        fi
        
        # 認証方法3: フォールバック（直接アクセス）
        if [ "$auth_method" = "direct" ]; then
            debug_log "DEBUG" "Falling back to direct access"
            $local_base_wget -O "$temp_file" "https://api.github.com/$endpoint" 2>/dev/null
            
            if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
                response=$(cat "$temp_file")
                if ! echo "$response" | grep -q '"message":"API rate limit exceeded'; then
                    debug_log "DEBUG" "Direct access successful"
                    break  # 成功したらループを抜ける
                fi
            fi
        fi
        
        # リトライ時の接続方法を変更（ローカル変数のみ更新）
        if [ $retry_count -eq 0 ] && [ -f "${CACHE_DIR}/network.ch" ]; then
            local current_network=$(cat "${CACHE_DIR}/network.ch")
            
            if [ "$current_network" = "v4v6" ]; then
                # デュアルスタックの場合、IPv4がデフォルト。失敗したらIPv6を試す
                local_wget_ipv_opt="-6"
                # ローカル変数を更新（関数内でのみ有効）
                local_base_wget="wget --no-check-certificate -q ${local_wget_ipv_opt} -O"
                local_base_wget_auth_bearer="wget --no-check-certificate -q ${local_wget_ipv_opt} -O \"\$1\" --header=\"Authorization: Bearer \$2\" \"\$3\""
                local_base_wget_auth_token="wget --no-check-certificate -q ${local_wget_ipv_opt} -O \"\$1\" --header=\"Authorization: token \$2\" \"\$3\""
                debug_log "DEBUG" "Switching to IPv6 for retry"
            elif [ "$current_network" = "v4" ] || [ "$current_network" = "v6" ]; then
                # シングルスタックの場合はタイムアウト値を増やす
                export WGET_TIMEOUT="--timeout=30"
                debug_log "DEBUG" "Increasing timeout for retry"
            fi
        fi
        
        retry_count=$((retry_count + 1))
    done
    
    # リトライ後の最終結果確認
    if [ -z "$response" ]; then
        debug_log "DEBUG" "Empty response from API request after $max_retries retries"
        rm -f "$temp_file" 2>/dev/null
        return 1
    fi
    
    if echo "$response" | grep -q '"message":"API rate limit exceeded'; then
        debug_log "DEBUG" "GitHub API rate limit exceeded"
        rm -f "$temp_file" 2>/dev/null
        return 1
    fi
    
    # 認証エラーチェック
    if echo "$response" | grep -q '"message":"Bad credentials"'; then
        debug_log "DEBUG" "GitHub API authentication failed: Bad credentials"
        rm -f "$temp_file" 2>/dev/null
        return 2
    fi
    
    # その他エラーチェック
    if echo "$response" | grep -q '"message":"'; then
        local error_msg=$(echo "$response" | grep -o '"message":"[^"]*"' | cut -d':' -f2- | tr -d '"')
        debug_log "DEBUG" "GitHub API error: $error_msg"
        rm -f "$temp_file" 2>/dev/null
        return 3
    fi

    # 成功
    echo "$response"
    rm -f "$temp_file" 2>/dev/null
    
    # wget設定を元に戻す関数を呼び出し
    setup_wget_options
    return 0
}

save_github_token() {
    token="$1"
    
    if [ -z "$token" ]; then
        debug_log "DEBUG" "Empty token provided, cannot save"
        return 1
    fi
    
    # トークンを保存して権限を設定
    echo "$token" > "$GITHUB_TOKEN_FILE"
    chmod 600 "$GITHUB_TOKEN_FILE"
    
    if [ $? -eq 0 ]; then
        debug_log "DEBUG" "GitHub token saved to $GITHUB_TOKEN_FILE"
        return 0
    else
        debug_log "DEBUG" "Failed to save token to $GITHUB_TOKEN_FILE"
        return 1
    fi
}

get_github_token() {
    local token=""
    
    if [ -f "$GITHUB_TOKEN_FILE" ] && [ -r "$GITHUB_TOKEN_FILE" ]; then
        # 改行や余分なスペースを削除したトークンを返す
        token=$(cat "$GITHUB_TOKEN_FILE" | tr -d '\n\r\t ' | head -1)
        if [ -n "$token" ]; then
            echo "$token"
            return 0
        fi
    fi
    
    # 環境変数からの取得（不要な文字も削除）
    if [ -n "$GITHUB_TOKEN" ]; then
        echo "$GITHUB_TOKEN" | tr -d '\n\r\t '
        return 0
    fi
    
    return 1
}

save_version_to_cache() {
    local file_name="$1"
    local version="$2"
    local script_file="$3"
    local tmp_file="${script_file}.tmp" # 一時ファイル名を変数に

    debug_log "DEBUG" "save_version_to_cache: Called for file='$file_name', version='$version', script_file='$script_file'"

    # バージョンが空でないかチェック
    if [ -z "$version" ]; then
        debug_log "DEBUG" "save_version_to_cache: Received empty version for file '$file_name'. Aborting cache save."
        return 1 # バージョンが空なら書き込みしない
    fi

    # tmpファイルを確実に削除しておく
    rm -f "$tmp_file" 2>/dev/null

    # script_file が存在する場合の処理
    if [ -f "$script_file" ]; then
        debug_log "DEBUG" "save_version_to_cache: File '$script_file' exists. Filtering existing entry for '$file_name'."
        # grep の実行と結果確認
        if grep -v "^${file_name}=" "$script_file" > "$tmp_file"; then
            debug_log "DEBUG" "save_version_to_cache: Successfully filtered '$script_file' to '$tmp_file'."
        else
            local grep_status=$?
            debug_log "DEBUG" "save_version_to_cache: grep command failed with status $grep_status for '$script_file'."
            # grep失敗時は一時ファイルを削除して終了（安全策）
            rm -f "$tmp_file" 2>/dev/null
            return 1
        fi

        # 新しいバージョン情報を追記
        debug_log "DEBUG" "save_version_to_cache: Appending new version '$version' for '$file_name' to '$tmp_file'."
        echo "${file_name}=${version}" >> "$tmp_file"

        # 一時ファイルの内容をデバッグログに出力（確認用）
        debug_log "DEBUG" "save_version_to_cache: Content of '$tmp_file' before move:"
        while IFS= read -r line || [ -n "$line" ]; do
             debug_log "DEBUG" "  | $line"
        done < "$tmp_file"

        # mv の実行と結果確認
        if mv "$tmp_file" "$script_file"; then
            debug_log "DEBUG" "save_version_to_cache: Successfully moved '$tmp_file' to '$script_file'."
        else
            local mv_status=$?
            debug_log "DEBUG" "save_version_to_cache: mv command failed with status $mv_status. Failed to update '$script_file'."
            # mv失敗時も一時ファイルを削除
            rm -f "$tmp_file" 2>/dev/null
            return 1
        fi
    else
        # script_file が存在しない場合の処理
        debug_log "DEBUG" "save_version_to_cache: File '$script_file' does not exist. Creating new file."
        # echo の実行と結果確認
        if echo "${file_name}=${version}" > "$script_file"; then
             debug_log "DEBUG" "save_version_to_cache: Successfully created '$script_file' with initial version."
        else
             local echo_status=$?
             debug_log "DEBUG" "save_version_to_cache: echo command failed with status $echo_status. Failed to create '$script_file'."
             return 1
        fi
    fi

    return 0 # 成功
}

# トークンセットアップ関数の改善版
setup_github_token() {
    echo "GitHub API Token Setup"
    echo "======================"
    
    # wget機能チェック
    local wget_capability=$(detect_wget_capabilities)
    debug_log "DEBUG" "Detected wget capability: $wget_capability"
    
    # トークン認証が利用できない場合は警告して終了
    if [ "$wget_capability" = "limited" ]; then
        echo "ERROR: GitHub API token authentication is not supported on this system."
        echo "Your version of wget does not support the required authentication methods."
        echo "API requests will be limited to 60 calls per hour."
        echo ""
        echo "This system uses a wget version without authentication support." 
        debug_log "DEBUG" "Token authentication not supported due to limited wget capabilities"
        return 1
    fi
    
    echo "This will save a GitHub Personal Access Token to $GITHUB_TOKEN_FILE"
    echo "The token will be used for API requests to avoid rate limits."
    echo ""
    
    printf "Enter your GitHub Personal Access Token: "
    read -r token
    echo ""
    
    if [ -n "$token" ]; then
        if save_github_token "$token"; then
            echo "Token has been saved successfully!"
            echo "API requests will now use authentication (up to 5000 calls per hour)."
            echo ""
            
            # 使用可能な認証方法の表示
            case "$wget_capability" in
                header)
                    echo "Your system supports header authentication (optimal)."
                    ;;
                basic)
                    echo "Your system supports basic authentication."
                    ;;
            esac
        else
            echo "Failed to save token. Please check permissions."
        fi
    else
        echo "No token entered. Operation cancelled."
    fi
}

# 🔴　トークン系　ここまで　🔴-------------------------------------------------------------------------------------------------------------------------------------------

# 🔵　ダウンロード系　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------

check_network_connectivity() {
    local ip_check_file="${CACHE_DIR}/network.ch"
    local ret4=1
    local ret6=1

    debug_log "DEBUG: Checking IPv4 connectivity"
    ping -c 1 -w 3 8.8.8.8 >/dev/null 2>&1
    ret4=$?

    debug_log "DEBUG: Checking IPv6 connectivity"
    ping6 -c 1 -w 3 2001:4860:4860::8888 >/dev/null 2>&1
    ret6=$?

    if [ "$ret4" -eq 0 ] && [ "$ret6" -eq 0 ]; then
        echo "v4v6" > "${ip_check_file}"
    elif [ "$ret4" -eq 0 ]; then
        echo "v4" > "${ip_check_file}"
    elif [ "$ret6" -eq 0 ]; then
        echo "v6" > "${ip_check_file}"
    else
        echo "" > "${ip_check_file}"
    fi
}

setup_wget_options() {
    # ネットワーク状態をキャッシュファイルから取得
    local network_type=""
    if [ -f "${CACHE_DIR}/network.ch" ]; then
        network_type=$(cat "${CACHE_DIR}/network.ch")
    fi
    
    # デフォルトのIPバージョンオプション（空=システム設定に従う）
    WGET_IPV_OPT=""
    
    # ネットワーク状態に応じてIPバージョンオプションを設定 
    case "$network_type" in
        v4)
            WGET_IPV_OPT="-4"
            debug_log "DEBUG" "Setting wget to use IPv4 only"
            ;;
        v6)
            WGET_IPV_OPT="-6"
            debug_log "DEBUG" "Setting wget to use IPv6 only"
            ;;
        v4v6|*)
            # デュアルスタック環境またはデフォルト
            WGET_IPV_OPT=""
            debug_log "DEBUG" "Using system default IP settings for wget"
            ;;
    esac
    
    debug_log "DEBUG" "wget IP version updated to: ${WGET_IPV_OPT}"
}

version_is_newer() {
    local current="$1"  # リモートバージョン
    local reference="$2"  # ローカルバージョン
    
    debug_log "DEBUG" "Comparing: Remote=$current, Local=$reference"
    
    # どちらかが不明の場合は更新必要
    if echo "$current $reference" | grep -q "No version\|unknown"; then
        debug_log "DEBUG" "Unknown version detected, update required"
        return 0
    fi
    
    # 完全一致の場合は更新不要
    if [ "$current" = "$reference" ]; then
        debug_log "DEBUG" "Exact match: No update needed"
        return 1
    fi
    
    # 日付部分を抽出（YYYY.MM.DD形式）
    local current_date=$(echo "$current" | grep -o "[0-9][0-9][0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]" | head -1)
    local reference_date=$(echo "$reference" | grep -o "[0-9][0-9][0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]" | head -1)
    
    # 日付が抽出できなかった場合は更新が必要
    if [ -z "$current_date" ] || [ -z "$reference_date" ]; then
        debug_log "DEBUG" "Date extraction failed: Update for safety"
        return 0
    fi
    
    # 日付を数値に変換（区切り文字を削除）
    local current_num=$(echo "$current_date" | tr -d '.')
    local reference_num=$(echo "$reference_date" | tr -d '.')
    
    # 数値比較（日付形式）
    if [ "$current_num" -gt "$reference_num" ]; then
        debug_log "DEBUG" "Remote date is newer: Update required"
        return 0  # リモート（current）が新しい
    elif [ "$current_num" -lt "$reference_num" ]; then
        debug_log "DEBUG" "Local date is newer: No update needed"
        return 1  # ローカル（reference）が新しい
    fi
    
    # 日付が同じ場合はSHA部分を比較
    local current_sha=$(echo "$current" | grep -o "\-[a-z0-9]*" | sed 's/^-//' | head -1)
    local reference_sha=$(echo "$reference" | grep -o "\-[a-z0-9]*" | sed 's/^-//' | head -1)
    
    # SHA情報をデバッグ出力
    debug_log "DEBUG" "SHA comparison: Remote=$current_sha, Local=$reference_sha"
    
    # 直接DL時の特別処理: ハッシュの先頭7文字だけ比較して異なる場合のみ更新
    if [ -n "$current_sha" ] && [ -n "$reference_sha" ]; then
        # どちらかにdirectというマークがあれば直接DLモードと判断
        if echo "$current $reference" | grep -q "direct"; then
            # 先頭7文字だけ比較（SHA-1とSHA-256を混在比較する場合の対策）
            local current_short=$(echo "$current_sha" | head -c 7)
            local reference_short=$(echo "$reference_sha" | head -c 7)
            
            if [ "$current_short" != "$reference_short" ]; then
                debug_log "DEBUG" "Different file hash in direct mode: Update required"
                return 0  # 異なるハッシュ
            else
                debug_log "DEBUG" "Same file hash in direct mode: No update needed"
                return 1  # 同一ハッシュ
            fi
        elif [ "$current_sha" != "$reference_sha" ]; then
            debug_log "DEBUG" "Different SHA: Update required"
            return 0  # 異なるコミット
        fi
    fi
    
    debug_log "DEBUG" "Same version or unable to compare: No update needed"
    return 1  # 同一バージョン
}

# OpenWrt環境のwget機能検出関数（改良版）
detect_wget_capabilities() {
    debug_log "DEBUG" "Detecting wget capabilities for current environment"
    
    local temp_file="${CACHE_DIR}/wget_help.tmp"
    local test_file="${CACHE_DIR}/wget_test_header.tmp"
    local header_support="no"
    local user_support="no"
    
    # wgetのヘルプを一時ファイルに保存（--helpがサポートされていない場合のため空ファイル作成）
    touch "$temp_file"
    wget --help > "$temp_file" 2>&1 || true
    
    # デバッグ用にwgetヘルプ内容の先頭行を記録
    debug_log "DEBUG" "wget help output beginning:"
    head -3 "$temp_file" | while read line; do
        debug_log "DEBUG" "  $line"
    done
    
    # OpenWrt/BusyBox wgetの検出（特徴的な出力パターン）
    if grep -q "BusyBox" "$temp_file" || ! grep -q "\-\-header" "$temp_file"; then
        debug_log "DEBUG" "Detected BusyBox wget without header support"
        rm -f "$temp_file"
        echo "limited"
        return 1
    fi
    
    # ヘッダーオプションのサポートを確認 - より厳密なパターン
    if grep -q -- "--header=" "$temp_file" || grep -q -- "--header " "$temp_file"; then
        debug_log "DEBUG" "wget supports header authentication"
        header_support="yes"
    fi
    
    # 基本認証のサポートを確認 - より厳密なパターン
    if grep -q -- "--user=" "$temp_file" || grep -q -- "--user " "$temp_file"; then
        debug_log "DEBUG" "wget supports basic authentication"
        user_support="yes"
    fi
    
    # 実際に機能テストを行う（ヘルプテキスト検出のバックアップ）
    if [ "$header_support" = "yes" ]; then
        debug_log "DEBUG" "Testing header support with actual command"
        rm -f "$temp_file"
        echo "header"
        return 0
    elif [ "$user_support" = "yes" ]; then
        debug_log "DEBUG" "Basic authentication is supported"
        rm -f "$temp_file"
        echo "basic" 
        return 0
    else
        debug_log "DEBUG" "No authentication methods supported"
        rm -f "$temp_file"
        echo "limited"
        return 1
    fi
}

# APIレート制限情報のチェックと取得（キャッシュ機能付き）
check_api_rate_limit() {
    local token="$(get_github_token)"
    local temp_file="${CACHE_DIR}/api_limit.tmp"
    local auth_method="direct"
    local current_time=$(date +%s)
    
    # IPバージョン設定の初期化確認
    if [ -z "$WGET_IPV_OPT" ]; then
        setup_wget_options
        debug_log "DEBUG" "Initialized wget IP options before checking API rate limit"
    fi
    
    # 先にキャッシュファイルをロード（初回実行時）
    if [ -z "$API_LAST_CHECK" ] && [ -f "${CACHE_DIR}/api_rate.ch" ]; then
        debug_log "DEBUG" "Loading API rate information from cache file"
        . "${CACHE_DIR}/api_rate.ch"
    fi
    
    # キャッシュ有効期間内の場合は保存値を返す
    if [ -n "$API_REMAINING" ] && [ $(( current_time - API_LAST_CHECK )) -lt ${API_CACHE_TTL:-60} ]; then
        debug_log "DEBUG" "Using cached API rate limit info: $API_REMAINING/$API_LIMIT, age: $(( current_time - API_LAST_CHECK ))s"
        echo "API: ${API_REMAINING}/${API_LIMIT} TTL:${API_RESET_TIME}m"
        return 0
    fi
    
    # 既存のファイルを削除
    [ -f "$temp_file" ] && rm -f "$temp_file"
    
    # wget機能と認証方法の検出（一度だけ実行）
    if [ -z "$WGET_CAPABILITY" ] && [ -n "$token" ]; then
        WGET_CAPABILITY=$(detect_wget_capabilities)
        debug_log "DEBUG" "Detected wget capability: $WGET_CAPABILITY"
        
        # トークンが設定されていても認証機能が使えない場合、警告表示
        if [ "$WGET_CAPABILITY" = "limited" ] && [ -f "$GITHUB_TOKEN_FILE" ]; then
            debug_log "DEBUG" "GitHub token is set but authentication is not supported with current wget version"
        fi
    fi
    
    # 認証方法の選択
    if [ -n "$token" ] && [ "$WGET_CAPABILITY" != "limited" ]; then
        if [ "$WGET_CAPABILITY" = "header" ]; then
            # ヘッダー認証（最適）
            $BASE_WGET -O "$temp_file" --header="Authorization: token $token" \
                 "https://api.github.com/rate_limit" 2>/dev/null
            
            if [ -f "$temp_file" ] && [ -s "$temp_file" ] && ! grep -q "Bad credentials\|Unauthorized" "$temp_file"; then
                auth_method="token"
                debug_log "DEBUG" "Successfully authenticated with token header"
            fi
        elif [ "$WGET_CAPABILITY" = "basic" ]; then
            # 基本認証
            $BASE_WGET -O "$temp_file" --user="$token" --password="x-oauth-basic" \
                 "https://api.github.com/rate_limit" 2>/dev/null
                 
            if [ -f "$temp_file" ] && [ -s "$temp_file" ] && ! grep -q "Bad credentials\|Unauthorized" "$temp_file"; then
                auth_method="basic"
                debug_log "DEBUG" "Successfully authenticated with basic auth"
            fi
        fi
    fi
    
    # 非認証リクエスト（認証に失敗した場合または認証なしの場合）
    if [ "$auth_method" = "direct" ]; then
        debug_log "DEBUG" "Making direct API request"
        $BASE_WGET -O "$temp_file" "https://api.github.com/rate_limit" 2>/dev/null
    fi
    
    # レスポンス解析
    if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        # レート情報の抽出
        local core_limit=$(grep -o '"limit"[ ]*:[ ]*[0-9]\+' "$temp_file" | head -1 | grep -o '[0-9]\+')
        local core_remaining=$(grep -o '"remaining"[ ]*:[ ]*[0-9]\+' "$temp_file" | head -1 | grep -o '[0-9]\+')
        local core_reset=$(grep -o '"reset"[ ]*:[ ]*[0-9]\+' "$temp_file" | head -1 | grep -o '[0-9]\+')
        
        # コアセクション優先
        if [ -z "$core_limit" ] || [ -z "$core_remaining" ] || [ -z "$core_reset" ]; then
            local core_section=$(sed -n '/"core":/,/},/p' "$temp_file")
            [ -z "$core_limit" ] && core_limit=$(echo "$core_section" | grep -o '"limit"[ ]*:[ ]*[0-9]\+' | head -1 | grep -o '[0-9]\+')
            [ -z "$core_remaining" ] && core_remaining=$(echo "$core_section" | grep -o '"remaining"[ ]*:[ ]*[0-9]\+' | head -1 | grep -o '[0-9]\+')
            [ -z "$core_reset" ] && core_reset=$(echo "$core_section" | grep -o '"reset"[ ]*:[ ]*[0-9]\+' | head -1 | grep -o '[0-9]\+')
        fi
        
        # リセット時間の計算
        local reset_minutes=60
        if [ -n "$core_reset" ] && [ "$core_reset" -gt 1000000000 ]; then
            local now_time=$(date +%s)
            if [ "$core_reset" -gt "$now_time" ]; then
                local reset_seconds=$(( core_reset - now_time ))
                reset_minutes=$(( reset_seconds / 60 ))
                [ "$reset_minutes" -lt 1 ] && reset_minutes=1
            else
                reset_minutes=0
            fi
        else
            # デフォルト値の設定
            if [ "$auth_method" != "direct" ]; then
                reset_minutes=60
            else
                reset_minutes=5
            fi
        fi
        
        # グローバル変数に保存（キャッシュ）
        API_REMAINING=$core_remaining
        API_LIMIT=$core_limit
        API_RESET_TIME=$reset_minutes
        API_AUTH_METHOD=$auth_method
        API_LAST_CHECK=$current_time
        
        # 値のチェックと整形
        [ -z "$API_LIMIT" ] && API_LIMIT="?"
        [ -z "$API_REMAINING" ] && API_REMAINING="?"
    else
        # 情報取得失敗時のデフォルト値
        if [ "$auth_method" != "direct" ]; then
            API_LIMIT="5000"
            API_REMAINING="?"
            API_RESET_TIME="60"
        else
            API_LIMIT="60"
            API_REMAINING="?"
            API_RESET_TIME="5"
        fi
        API_AUTH_METHOD=$auth_method
        API_LAST_CHECK=$current_time
    fi
    
    # キャッシュ保存
    save_api_rate_cache
    
    # 結果文字列の生成
    local status_text="API: ${API_REMAINING}/${API_LIMIT} TTL:${API_RESET_TIME}m"
    debug_log "DEBUG" "Final API status: $status_text (auth_method=$auth_method)"
    
    # 一時ファイル削除
    [ -f "$temp_file" ] && rm -f "$temp_file"
    
    # 結果を返す
    echo "$status_text"
}

# キャッシュにAPIレート制限情報を保存
save_api_rate_cache() {
    local cache_file="${CACHE_DIR}/api_rate.ch"
    
    # キャッシュディレクトリがなければ作成
    [ ! -d "$CACHE_DIR" ] && mkdir -p "$CACHE_DIR"
    
    # 保存内容の作成
    {
        echo "API_REMAINING=\"$API_REMAINING\""
        echo "API_LIMIT=\"$API_LIMIT\""
        echo "API_RESET_TIME=\"$API_RESET_TIME\""
        echo "API_AUTH_METHOD=\"$API_AUTH_METHOD\""
        echo "API_LAST_CHECK=\"$API_LAST_CHECK\""
    } > "$cache_file"
    
    debug_log "DEBUG" "API rate info cached to $cache_file"
}

clean_version_string() {
    local version_str="$1"
    
    # 1. 改行と復帰を削除
    local cleaned=$(printf "%s" "$version_str" | tr -d '\n\r')
    
    # 2. 角括弧を削除
    cleaned=$(printf "%s" "$cleaned" | sed 's/\[//g; s/\]//g')
    
    # 3. ANSIエスケープコードを削除
    cleaned=$(printf "%s" "$cleaned" | sed 's/\x1b\[[0-9;]*[mK]//g')
    
    # 4. バージョン番号の抽出（シンプルな方法）
    if echo "$cleaned" | grep -q '20[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]'; then
        # 年.月.日 形式のバージョンを抽出
        local date_part=$(printf "%s" "$cleaned" | grep -o '20[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]')
        
        # バージョン文字列の残りの部分があれば追加
        if echo "$cleaned" | grep -q "${date_part}-"; then
            local remainder=$(printf "%s" "$cleaned" | sed "s/.*${date_part}-//; s/[^0-9a-zA-Z-].*//")
            printf "%s-%s" "$date_part" "$remainder"
        else
            printf "%s" "$date_part"
        fi
    else
        # バージョンが見つからない場合は元の文字列をクリーニングしたものを返す
        printf "%s" "$cleaned"
    fi
}

# コミット情報取得関数 (デバッグログ追加版)
get_commit_version() {
    local file_path="$1"
    local force_refresh="$2"
    local temp_file="${CACHE_DIR}/commit_info_$(echo "$file_path" | tr '/' '_').tmp"
    local direct_file="${CACHE_DIR}/direct_file_$(echo "$file_path" | tr '/' '_').tmp"
    local repo_owner="site-u2023"
    local repo_name="aios"
    local version="EMPTY_VERSION" # 初期値
    local auth_method="unknown"   # 初期値
    # --- 追加ログ用変数 ---
    local step="start"
    local api_url=""
    local token_present="no"
    local wget_command=""
    local wget_status=""
    local response_preview=""
    local commit_date=""
    local commit_sha=""

    # --- デバッグログ ---
    debug_log "DEBUG" "[get_commit_version] ----- Start for file='$file_path' -----" # 区切り線追加
    debug_log "DEBUG" "[get_commit_version] Args: force_refresh='$force_refresh', DOWNLOAD_METHOD='$DOWNLOAD_METHOD', SKIP_CACHE='$SKIP_CACHE'"

    # DOWNLOAD_METHOD による分岐
    step="check_download_method"
    debug_log "DEBUG" "[get_commit_version] [$step] DOWNLOAD_METHOD is '$DOWNLOAD_METHOD'"
    if [ "$DOWNLOAD_METHOD" = "direct" ]; then
        step="direct_mode_start"
        debug_log "DEBUG" "[get_commit_version] [$step] Entering direct download mode."

        # --- 直接ダウンロード処理 ---
        local retry_count=0
        local direct_download_success=0
        while [ $retry_count -le 1 ]; do
            step="direct_mode_retry_$retry_count"
            # ... (IP設定ロジックは変更なし、ログは内部で出力される) ...
            local current_wget_opt="$WGET_IPV_OPT" # IP設定後のオプションを使用

            rm -f "$direct_file" 2>/dev/null
            wget_command="wget -q --no-check-certificate ${current_wget_opt} -O \"$direct_file\" \"https://raw.githubusercontent.com/$repo_owner/$repo_name/main/$file_path\""
            debug_log "DEBUG" "[get_commit_version] [$step] Attempting direct download. Command: $wget_command" # コマンド表示
            if eval "$wget_command" 2>/dev/null; then # eval を使用してコマンド実行
                wget_status=$? # eval の終了ステータス
                debug_log "DEBUG" "[get_commit_version] [$step] wget command finished. Status: $wget_status"
                if [ -s "$direct_file" ]; then
                    step="direct_mode_hash_calc"
                    debug_log "DEBUG" "[get_commit_version] [$step] File '$direct_file' downloaded successfully. Calculating hash."
                    # ファイル内容の一部をプレビュー (最初の数行)
                    response_preview=$(head -n 3 "$direct_file" | sed 's/$/\\n/' | tr -d '\n')
                    debug_log "DEBUG" "[get_commit_version] [$step] File preview (first 3 lines): $response_preview" # 追加ログ
                    local file_hash=$(sha256sum "$direct_file" 2>/dev/null | cut -c1-7)
                    rm -f "$direct_file" 2>/dev/null
                    local today=$(date +%Y.%m.%d)
                    version="$today-$file_hash"
                    auth_method="direct"
                    direct_download_success=1
                    debug_log "DEBUG" "[get_commit_version] [$step] Hash calculated: '$file_hash'. Generated version: '$version'. Auth: '$auth_method'."
                    setup_wget_options
                    echo "$version $auth_method"
                    return 0
                else
                    step="direct_mode_empty_file"
                    debug_log "DEBUG" "[get_commit_version] [$step] wget succeeded but '$direct_file' is empty or not found." # レベル変更しない
                    rm -f "$direct_file" 2>/dev/null
                fi
            else
                wget_status=$? # eval の終了ステータス
                step="direct_mode_wget_fail"
                debug_log "DEBUG" "[get_commit_version] [$step] wget command failed. Status: $wget_status" # レベル変更しない
            fi
            retry_count=$((retry_count + 1))
            if [ $retry_count -le 1 ]; then sleep 1; fi
        done

        # 直接ダウンロード失敗時の処理
        step="direct_mode_failed_fallback"
        debug_log "DEBUG" "[get_commit_version] [$step] Failed to download file directly after retries." # レベル変更しない
        rm -f "$direct_file" 2>/dev/null
        setup_wget_options
        version="$(date +%Y.%m.%d)-unknown"
        auth_method="directfail" # 失敗時の auth_method を変更
        debug_log "DEBUG" "[get_commit_version] [$step] Returning fallback version: '$version $auth_method'"
        echo "$version $auth_method"
        return 1
        # --- 直接ダウンロード処理ここまで ---

    fi # DOWNLOAD_METHOD = "direct" の if の終わり

    # --- 以下、DOWNLOAD_METHOD = "api" の場合の処理 ---
    step="api_mode_start"
    debug_log "DEBUG" "[get_commit_version] [$step] Entering API download mode."

    # --- キャッシュチェック処理 ---
    step="api_mode_cache_check"
    local cache_checked="false"
    local proceed_to_api="true"

    # キャッシュチェック条件をログ出力
    debug_log "DEBUG" "[get_commit_version] [$step] Checking cache conditions: SKIP_CACHE='$SKIP_CACHE', force_refresh='$force_refresh', FORCE='$FORCE'"
    if [ "$SKIP_CACHE" != "true" ] && [ "$force_refresh" != "true" ] && [ "$FORCE" != "true" ]; then
        cache_checked="true"
        debug_log "DEBUG" "[get_commit_version] [$step] Attempting to retrieve from commit cache for '$file_path'."
        local cache_result=$(get_commit_from_cache "$file_path") # get_commit_from_cache 内のログも参照
        local cache_status=$?

        if [ $cache_status -eq 0 ] && [ -n "$cache_result" ]; then
            step="api_mode_cache_hit"
            debug_log "DEBUG" "[get_commit_version] [$step] Valid cache hit. Returning cached value: '$cache_result'"
            echo "$cache_result"
            return 0
        else
            step="api_mode_cache_miss"
            if [ $cache_status -ne 0 ]; then
                 debug_log "DEBUG" "[get_commit_version] [$step] Cache miss or invalid (status: $cache_status)."
            elif [ -z "$cache_result" ]; then
                 # 以前 WARN だった箇所
                 debug_log "DEBUG" "[get_commit_version] [$step] Cache status was 0 but result was empty. Treating as cache miss." # レベル変更しない
            fi
            proceed_to_api="true"
        fi
    else
         step="api_mode_cache_skip"
         debug_log "DEBUG" "[get_commit_version] [$step] Cache skipped due to flags."
         proceed_to_api="true"
    fi
    # --- キャッシュチェック処理ここまで ---

    # --- API呼び出しに進む場合のみ以下の処理を実行 ---
    step="api_mode_proceed_check"
    debug_log "DEBUG" "[get_commit_version] [$step] Proceed to API call: '$proceed_to_api'"
    if [ "$proceed_to_api" = "true" ]; then
        step="api_mode_api_call_start"
        api_url="repos/${repo_owner}/${repo_name}/commits?path=${file_path}&per_page=1"
        auth_method="direct" # 初期値
        local retry_count=0
        local max_retries=2 # APIリトライ回数
        local token=$(get_github_token)
        token_present=$( [ -n "$token" ] && echo "yes" || echo "no" ) # トークン有無
        local api_call_successful="false"

        debug_log "DEBUG" "[get_commit_version] [$step] Starting API call loop. URL: '$api_url', Token present: $token_present"

        while [ $retry_count -le $max_retries ]; do
            step="api_mode_api_retry_$retry_count"
            if [ $retry_count -gt 0 ]; then
                debug_log "DEBUG" "[get_commit_version] [$step] Retry attempt $retry_count"
                sleep 1
            fi

            # 認証方法に応じたAPI呼び出し
            rm -f "$temp_file" 2>/dev/null
            local current_api_auth_method="direct"
            local current_wget_opt="$WGET_IPV_OPT" # IP設定後のオプションを使用

            debug_log "DEBUG" "[get_commit_version] [$step] Determining API auth method. Token: $token_present, WGET_CAPABILITY: '$WGET_CAPABILITY', API_AUTH_METHOD(cached): '$API_AUTH_METHOD'."

            # 認証方法選択ロジックをログで追跡
            wget_command="" # コマンド初期化
            if [ "$token_present" = "yes" ] && [ "$API_AUTH_METHOD" != "direct" ]; then
                 if [ "$API_AUTH_METHOD" = "token" ] || [ "$WGET_CAPABILITY" = "header" ]; then
                     debug_log "DEBUG" "[get_commit_version] [$step] Trying wget with token header auth."
                     wget_command="wget -q --no-check-certificate ${current_wget_opt} -O \"$temp_file\" --header=\"Authorization: token $token\" \"https://api.github.com/$api_url\""
                     current_api_auth_method="token"
                 elif [ "$API_AUTH_METHOD" = "basic" ] || [ "$WGET_CAPABILITY" = "basic" ]; then
                     debug_log "DEBUG" "[get_commit_version] [$step] Trying wget with basic auth."
                     wget_command="wget -q --no-check-certificate ${current_wget_opt} -O \"$temp_file\" --user=\"$token\" --password=\"x-oauth-basic\" \"https://api.github.com/$api_url\""
                     current_api_auth_method="basic"
                 else
                     debug_log "DEBUG" "[get_commit_version] [$step] Token present but no supported auth method. Falling back to direct."
                     wget_command="wget -q --no-check-certificate ${current_wget_opt} -O \"$temp_file\" \"https://api.github.com/$api_url\""
                     current_api_auth_method="direct"
                 fi
            else
                debug_log "DEBUG" "[get_commit_version] [$step] Trying wget with direct API call (no auth or API_AUTH_METHOD=direct)."
                wget_command="wget -q --no-check-certificate ${current_wget_opt} -O \"$temp_file\" \"https://api.github.com/$api_url\""
                current_api_auth_method="direct"
            fi

            debug_log "DEBUG" "[get_commit_version] [$step] Executing API wget. Command: $wget_command" # コマンド表示
            if eval "$wget_command" 2>/dev/null; then # eval を使用してコマンド実行
                 wget_api_status=$?
            else
                 wget_api_status=$? # eval 自体が失敗した場合もステータス取得
            fi
            debug_log "DEBUG" "[get_commit_version] [$step] wget API call finished. Status: $wget_api_status. Auth method tried: $current_api_auth_method."

            # 応答チェック
            step="api_mode_response_check_$retry_count"
            if [ -s "$temp_file" ]; then
                debug_log "DEBUG" "[get_commit_version] [$step] API response file '$temp_file' exists and is not empty."
                # レスポンス内容の一部をプレビュー (最初の数行)
                response_preview=$(head -n 5 "$temp_file" | sed 's/$/\\n/' | tr -d '\n')
                debug_log "DEBUG" "[get_commit_version] [$step] Response preview (first 5 lines): $response_preview" # 追加ログ

                # エラーメッセージが含まれていないか確認
                if ! grep -q "API rate limit exceeded\|Not Found\|Bad credentials" "$temp_file"; then
                    step="api_mode_success_$retry_count"
                    debug_log "DEBUG" "[get_commit_version] [$step] Successfully retrieved valid commit information via API."
                    auth_method=$current_api_auth_method
                    api_call_successful="true"
                    break # 成功したらループを抜ける
                else
                    step="api_mode_api_error_$retry_count"
                    # 以前 WARN だった箇所
                    debug_log "DEBUG" "[get_commit_version] [$step] API response file '$temp_file' contains error messages." # レベル変更しない
                    grep "message" "$temp_file" | while IFS= read -r line; do debug_log "DEBUG" "  [get_commit_version] [$step] API Error: $line"; done
                fi
            else
                 step="api_mode_empty_response_$retry_count"
                 # 以前 WARN だった箇所
                 debug_log "DEBUG" "[get_commit_version] [$step] API response file '$temp_file' is empty or not found after wget call." # レベル変更しない
            fi

            # ... (リトライ時のIP切り替えロジックは変更なし、ログは内部で出力される) ...
            retry_count=$((retry_count + 1))
        done # API 呼び出しリトライの while の終わり
        debug_log "DEBUG" "[get_commit_version] Exited API call loop. api_call_successful='$api_call_successful'" # 追加ログ

        # --- API呼び出し成功時の処理 ---
        step="api_mode_process_success"
        debug_log "DEBUG" "[get_commit_version] [$step] Checking if API call was successful: '$api_call_successful'"
        if [ "$api_call_successful" = "true" ]; then
            debug_log "DEBUG" "[get_commit_version] [$step] Processing successful API response from '$temp_file'."

            # SHA抽出
            step="api_mode_extract_sha"
            commit_sha=$(grep -o '"sha"[[:space:]]*:[[:space:]]*"[a-f0-9]\{7,40\}"' "$temp_file" | head -1 | cut -d'"' -f4 | head -c 7)
            debug_log "DEBUG" "[get_commit_version] [$step] Primary SHA grep result: '$commit_sha'" # 追加ログ
            if [ -z "$commit_sha" ]; then
                 commit_sha=$(grep -o '[a-f0-9]\{40\}' "$temp_file" | head -1 | head -c 7)
                 debug_log "DEBUG" "[get_commit_version] [$step] Fallback SHA grep result: '$commit_sha'" # 追加ログ
            fi

            # 日付抽出
            step="api_mode_extract_date"
            commit_date=$(grep -o '"date"[[:space:]]*:[[:space:]]*"[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}T' "$temp_file" | head -1 | cut -d'"' -f4 | cut -dT -f1)
             debug_log "DEBUG" "[get_commit_version] [$step] Primary Date grep result: '$commit_date'" # 追加ログ
            if [ -z "$commit_date" ]; then
                commit_date=$(grep -o '[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}T[0-9]\{2\}:[0-9]\{2\}:[0-9]\{2\}Z' "$temp_file" | head -1 | cut -dT -f1)
                 debug_log "DEBUG" "[get_commit_version] [$step] Fallback Date grep result: '$commit_date'" # 追加ログ
            fi

            # 情報が取得できない場合はフォールバック
            step="api_mode_check_extracted"
            debug_log "DEBUG" "[get_commit_version] [$step] Checking extracted info: SHA='$commit_sha', Date='$commit_date'" # 追加ログ
            if [ -z "$commit_date" ] || [ -z "$commit_sha" ]; then
                step="api_mode_extract_fail"
                # 以前 WARN だった箇所
                debug_log "DEBUG" "[get_commit_version] [$step] Failed to extract commit SHA or Date. Using fallback values." # レベル変更しない
                # ... (フォールバック抽出ロジックは変更なし) ...
                [ -z "$commit_sha" ] && commit_sha="unknownsha"
                [ -z "$commit_date" ] && commit_date=$(date +%Y-%m-%d)
                # 以前 WARN だった箇所
                debug_log "DEBUG" "[get_commit_version] [$step] Using fallback SHA='$commit_sha', Date='$commit_date'." # レベル変更しない
                auth_method="fallback"
            fi

            # 結果の組み立て
            step="api_mode_generate_version"
            debug_log "DEBUG" "[get_commit_version] [$step] Generating final version string. Date='$commit_date', SHA='$commit_sha'" # 追加ログ
            if [ -n "$commit_date" ] && [ -n "$commit_sha" ]; then
                local formatted_date=$(echo "$commit_date" | tr '-' '.')
                version="${formatted_date}-${commit_sha}"
                debug_log "DEBUG" "[get_commit_version] [$step] Successfully generated version: '$version'. Auth: '$auth_method'."
                rm -f "$temp_file" 2>/dev/null
                setup_wget_options
                save_commit_to_cache "$file_path" "$version" "$auth_method" # save_commit_to_cache 内のログも参照
                echo "$version $auth_method"
                return 0
            else
                step="api_mode_generate_fail"
                # 以前 ERROR だった箇所
                debug_log "DEBUG" "[get_commit_version] [$step] Version generation failed unexpectedly. SHA='$commit_sha', Date='$commit_date'." # レベル変更しない
                # ここで return せずに下の API 失敗処理に進む
                version="" # version を空にして下の処理に進ませる
            fi
        fi # api_call_successful = true の if の終わり

        # --- APIでの取得に失敗した場合 or バージョン生成に失敗した場合 ---
        step="api_mode_handle_failure"
        debug_log "DEBUG" "[get_commit_version] [$step] Checking if API failed or version gen failed. api_call_successful='$api_call_successful', version='$version'" # 追加ログ
        if [ "$api_call_successful" = "false" ] || { [ "$api_call_successful" = "true" ] && [ -z "$version" ]; }; then
            if [ "$api_call_successful" = "true" ] && [ -z "$version" ]; then
                 step="api_mode_gen_fail_fallback"
                 # 以前 WARN だった箇所
                 debug_log "DEBUG" "[get_commit_version] [$step] API call was successful but version generation failed. Falling back to direct download." # レベル変更しない
            else
                 step="api_mode_api_fail_fallback"
                 debug_log "DEBUG" "[get_commit_version] [$step] API call failed. Falling back to direct file check." # 追加ログ
            fi
            rm -f "$temp_file" 2>/dev/null

            # --- 直接ダウンロード処理 (APIフォールバック用) ---
            step="api_fallback_direct_start"
            retry_count=0 # リトライカウントリセット
            local direct_download_fallback_success=0
            while [ $retry_count -le 1 ]; do # リトライは1回まで
                step="api_fallback_direct_retry_$retry_count"
                # ... (IP設定ロジックは変更なし) ...
                local current_wget_opt="$WGET_IPV_OPT"

                rm -f "$direct_file" 2>/dev/null
                wget_command="wget -q --no-check-certificate ${current_wget_opt} -O \"$direct_file\" \"https://raw.githubusercontent.com/$repo_owner/$repo_name/main/$file_path\""
                debug_log "DEBUG" "[get_commit_version] [$step] Attempting fallback direct download. Command: $wget_command" # コマンド表示
                if eval "$wget_command" 2>/dev/null; then
                    wget_status=$?
                    debug_log "DEBUG" "[get_commit_version] [$step] Fallback wget command finished. Status: $wget_status"
                    if [ -s "$direct_file" ]; then
                        step="api_fallback_hash_calc"
                        debug_log "DEBUG" "[get_commit_version] [$step] Fallback file '$direct_file' downloaded. Calculating hash."
                        # ファイル内容の一部をプレビュー
                        response_preview=$(head -n 3 "$direct_file" | sed 's/$/\\n/' | tr -d '\n')
                        debug_log "DEBUG" "[get_commit_version] [$step] File preview (first 3 lines): $response_preview" # 追加ログ
                        local file_hash=$(sha256sum "$direct_file" 2>/dev/null | cut -c1-7)
                        rm -f "$direct_file" 2>/dev/null
                        local today=$(date +%Y.%m.%d)
                        version="$today-$file_hash"
                        auth_method="directfallback"
                        direct_download_fallback_success=1
                        debug_log "DEBUG" "[get_commit_version] [$step] Fallback hash calculated: '$file_hash'. Generated version: '$version'. Auth: '$auth_method'."
                        setup_wget_options
                        save_commit_to_cache "$file_path" "$version" "$auth_method"
                        echo "$version $auth_method"
                        return 0
                    else
                        step="api_fallback_empty_file"
                        # 以前 WARN だった箇所
                        debug_log "DEBUG" "[get_commit_version] [$step] Fallback wget succeeded but '$direct_file' is empty or not found." # レベル変更しない
                        rm -f "$direct_file" 2>/dev/null
                    fi
                else
                     wget_status=$?
                     step="api_fallback_wget_fail"
                     # 以前 WARN だった箇所
                     debug_log "DEBUG" "[get_commit_version] [$step] Fallback wget command failed. Status: $wget_status" # レベル変更しない
                fi
                retry_count=$((retry_count + 1))
                if [ $retry_count -le 1 ]; then sleep 1; fi
            done

            # 直接ダウンロードも失敗した場合 (APIフォールバック)
            step="api_fallback_failed_final"
            # 以前 ERROR だった箇所
            debug_log "DEBUG" "[get_commit_version] [$step] Failed to download file directly via fallback after retries." # レベル変更しない
            rm -f "$direct_file" "$temp_file" 2>/dev/null
            setup_wget_options
            version="$(date +%Y.%m.%d)-apifail"
            auth_method="apifail"
            debug_log "DEBUG" "[get_commit_version] [$step] Returning final fallback version: '$version $auth_method'"
            echo "$version $auth_method"
            return 1
            # --- 直接ダウンロード処理 (APIフォールバック用) ここまで ---
        fi # API失敗 or version生成失敗の if の終わり
    fi # proceed_to_api = true の if の終わり

    # --- 全ての方法が失敗した場合 (通常ここには到達しないはず) ---
    step="unexpected_end"
    # 以前 CRITICAL だった箇所
    debug_log "DEBUG" "[get_commit_version] [$step] Reached end of function unexpectedly. This should not happen." # レベル変更しない
    rm -f "$temp_file" "$direct_file" 2>/dev/null
    setup_wget_options
    version="$(date +%Y.%m.%d)-critical"
    auth_method="critical"
    echo "$version $auth_method"
    return 1
}

# ファイルをダウンロードまたは更新する関数 (デバッグログ追加版)
download() {
    # ... (関数の前半、変数定義などは変更なし) ...
    local file_path="$1"
    local target_dir="$2"
    local force="$3"
    local file_name=$(basename "$file_path")
    local target_path="${target_dir}/${file_name}"
    local repo_owner="site-u2023"
    local repo_name="aios"

    debug_log "DEBUG" "[download] Starting for file='$file_path', target='$target_path', force='$force'" # 既存ログに [download] 追加

    # ... (ターゲットディレクトリ作成は変更なし) ...

    # 最新のコミットバージョンを取得
    debug_log "DEBUG" "[download] Calling get_commit_version for '$file_path' with force='$force'" # 追加ログ
    local latest_version_info=$(get_commit_version "$file_path" "$force")
    local lv_status=$?
    debug_log "DEBUG" "[download] get_commit_version finished for '$file_path'. Status: $lv_status, Info: '$latest_version_info'" # 追加ログ

    # get_commit_version の結果を解析
    local latest_version_val=""
    local latest_version_auth=""
    if [ $lv_status -eq 0 ] && [ -n "$latest_version_info" ]; then
        latest_version_val=$(echo "$latest_version_info" | cut -d' ' -f1)
        latest_version_auth=$(echo "$latest_version_info" | cut -d' ' -f2)
        debug_log "DEBUG" "[download] Got latest version '$latest_version_val' (auth: '$latest_version_auth') for '$file_path'." # 既存ログに [download] 追加
    else
        debug_log "DEBUG" "[download] Failed to get latest version for '$file_path' (status: $lv_status). Cannot proceed." # 既存ログに [download] 追加
        printf "%s: %s %s %s\n" "$(get_message "DOWNLOADED_LABEL")" "$file_name" "EMPTY_VERSION" "$(get_api_limit_info)"
        return 1
    fi

    # 現在のローカルバージョンを取得
    local current_version="none"
    if [ -f "$target_path" ]; then
        current_version=$(head -n 1 "$target_path" | grep -o '[0-9]\{4\}\.[0-9]\{2\}\.[0-9]\{2\}-[a-f0-9]\{7\}' || echo "unknown")
        debug_log "DEBUG" "[download] Current local version for '$target_path' is '$current_version'." # 既存ログに [download] 追加
    else
        debug_log "DEBUG" "[download] Local file '$target_path' does not exist." # 既存ログに [download] 追加
        current_version="none"
    fi

    # バージョン比較とダウンロード実行判断
    local download_required="false" # 追加: ダウンロード要否フラグ
    local reason="unknown"          # 追加: ダウンロード理由
    if [ "$force" = "true" ]; then
        download_required="true"
        reason="force flag"
    elif [ "$current_version" = "none" ]; then
        download_required="true"
        reason="local file missing"
    elif [ "$current_version" = "unknown" ]; then
         download_required="true"
         reason="local version unknown"
    elif [ "$current_version" != "$latest_version_val" ]; then
        # version_is_newer を呼び出す前にログ追加
        debug_log "DEBUG" "[download] Versions differ, calling version_is_newer ('$latest_version_val', '$current_version')" # 追加ログ
        if version_is_newer "$latest_version_val" "$current_version"; then
             download_required="true"
             reason="remote is newer"
        else
             download_required="false"
             reason="local is same or newer"
        fi
    else
        download_required="false" # バージョン一致
        reason="versions match"
    fi
    debug_log "DEBUG" "[download] Download required check result: '$download_required' (Reason: $reason)" # 追加ログ

    if [ "$download_required" = "true" ]; then
        debug_log "DEBUG" "[download] Download required for '$file_path'." # 既存ログに [download] 追加

        # ダウンロード実行
        local download_success="false"
        local retry_count_dl=0
        local max_retries_dl=1

        # --- 根本原因調査ログ (-le エラー関連) ---
        debug_log "DEBUG" "[download] Before retry loop: download_success='$download_success', retry_count_dl='$retry_count_dl', max_retries_dl='$max_retries_dl'" # 追加ログ
        # 変数チェック（デバッグ用、修正はまだしない）
        case "$retry_count_dl" in ''|*[!0-9]*) debug_log "DEBUG" "[download] WARNING: retry_count_dl is not a number before loop: '$retry_count_dl'" ;; esac
        case "$max_retries_dl" in ''|*[!0-9]*) debug_log "DEBUG" "[download] WARNING: max_retries_dl is not a number before loop: '$max_retries_dl'" ;; esac
        # --- 根本原因調査ログここまで ---

        # while ループの条件式をデバッグログで表示
        debug_log "DEBUG" "[download] Entering while loop condition check: [ \"$download_success\" = \"false\" ] && [ $retry_count_dl -le $max_retries_dl ]" # 追加ログ

        while [ "$download_success" = "false" ] && [ $retry_count_dl -le $max_retries_dl ]; do
            debug_log "DEBUG" "[download] Inside retry loop (Attempt $((retry_count_dl + 1)))" # 追加ログ
            if [ $retry_count_dl -gt 0 ]; then
                debug_log "DEBUG" "[download] Retrying download ($((retry_count_dl + 1))) for '$file_path'..." # 既存ログに [download] 追加
                sleep 1
            fi

            # 実際のダウンロードコマンド (wget)
            debug_log "DEBUG" "[download] Attempting wget download with opt '$WGET_IPV_OPT' for '$file_path' to '${target_path}.tmp'." # 既存ログを詳細化
            rm -f "${target_path}.tmp" 2>/dev/null
            if wget -q --no-check-certificate ${WGET_IPV_OPT} -O "${target_path}.tmp" "https://raw.githubusercontent.com/$repo_owner/$repo_name/main/$file_path" 2>/dev/null; then
                local wget_status=$?
                debug_log "DEBUG" "[download] wget command finished for '${target_path}.tmp' with status $wget_status." # 既存ログに [download] 追加
                if [ -s "${target_path}.tmp" ]; then
                    debug_log "DEBUG" "[download] Temporary file '${target_path}.tmp' exists and is not empty. Attempting move." # 追加ログ
                    if mv "${target_path}.tmp" "$target_path"; then
                        debug_log "DEBUG" "[download] Successfully downloaded and moved to '$target_path'." # 既存ログに [download] 追加
                        download_success="true"
                    else
                         local mv_status=$?
                        debug_log "DEBUG" "[download] Failed to move temporary file '${target_path}.tmp' to '$target_path'. Status: $mv_status" # 既存ログを詳細化
                        rm -f "${target_path}.tmp" 2>/dev/null
                    fi
                else
                    debug_log "DEBUG" "[download] wget succeeded but temporary file '${target_path}.tmp' is empty or missing." # 既存ログに [download] 追加
                    rm -f "${target_path}.tmp" 2>/dev/null
                fi
            else
                local wget_status=$?
                debug_log "DEBUG" "[download] wget command failed with status $wget_status for '$file_path'." # 既存ログに [download] 追加
                rm -f "${target_path}.tmp" 2>/dev/null
                # ... (IP設定切り替えロジックは変更なし) ...
            fi

            retry_count_dl=$((retry_count_dl + 1))
            # --- 根本原因調査ログ (-le エラー関連) ---
            debug_log "DEBUG" "[download] Incremented retry_count_dl to: '$retry_count_dl'" # 追加ログ
            case "$retry_count_dl" in ''|*[!0-9]*) debug_log "DEBUG" "[download] WARNING: retry_count_dl became non-numeric after increment: '$retry_count_dl'" ;; esac
            # --- 根本原因調査ログここまで ---

            # ループ継続条件の再評価のため、ここで待機はしない
            if [ "$download_success" = "false" ] && [ $retry_count_dl -le $max_retries_dl ]; then
                 debug_log "DEBUG" "[download] Download failed, will retry. Sleeping 1s." # 追加ログ
                 sleep 1
            fi
            # ループ継続条件チェックのログを追加
            debug_log "DEBUG" "[download] Re-checking while loop condition: [ \"$download_success\" = \"false\" ] && [ $retry_count_dl -le $max_retries_dl ]" # 追加ログ

        done # ダウンロードリトライループの終わり
        debug_log "DEBUG" "[download] Exited retry loop. download_success='$download_success'" # 追加ログ

        # ダウンロード結果の最終確認とメッセージ表示
        if [ "$download_success" = "true" ]; then
            printf "%s: %s %s %s\n" "$(get_message "DOWNLOADED_LABEL")" "$file_name" "$latest_version_val" "$(get_api_limit_info)"
        else
            debug_log "DEBUG" "[download] Failed to download '$file_path' after retries." # 既存ログに [download] 追加
            printf "%s: %s %s %s\n" "$(get_message "DOWNLOAD_FAILED_LABEL")" "$file_name" "$latest_version_val" "$(get_api_limit_info)"
            setup_wget_options
            return 1
        fi

    else
        # ファイルは最新
        debug_log "DEBUG" "[download] File '$file_path' is already up to date (version: $current_version)." # 既存ログに [download] 追加
        printf "%s: %s %s %s %s\n" "$(get_message "LATEST_FILE_LABEL")" "$file_name" "$current_version" "$(get_api_limit_info)" "$(get_message "LOADED_LABEL")"
    fi

    setup_wget_options
    return 0
}

download_check_version() {
    local file_name="$1"
    local script_file="${CACHE_DIR}/script.ch"
    local dummy_version="No version control"

    # バージョン情報の取得
    local remote_version_info=$(get_commit_version "$file_name")
    local remote_version=$(printf "%s" "$remote_version_info" | cut -d' ' -f1)
    local auth_method=$(printf "%s" "$remote_version_info" | cut -d' ' -f2) # get_commit_version が返した認証方法を取得
    local local_version=""

    # ローカルバージョンの取得
    if [ -f "$script_file" ]; then
        local_version=$(grep "^${file_name}=" "$script_file" | cut -d'=' -f2)
    fi
    [ -z "$local_version" ] && local_version="$dummy_version"

    local clean_remote_version=$(clean_version_string "$remote_version")
    local clean_local_version=$(clean_version_string "$local_version")

    # --- APIレート制限情報の取得 (direct モード時はスキップ) ---
    local api_status=""
    if [ "$DOWNLOAD_METHOD" = "direct" ]; then
        # direct モードの場合は API チェックをスキップし、固定値を設定
        # auth_method が 'direct' であることも確認 (get_commit_version が期待通り動作しているか)
        if [ "$auth_method" = "direct" ]; then
             api_status="API: N/A (Direct)"
             debug_log "DEBUG" "Direct download mode: Skipping API rate limit check for $file_name"
        else
             # direct モードなのに auth_method が direct でない場合は警告
             api_status="API: ??? (Inconsistent)"
             debug_log "DEBUG" "Inconsistent state: DOWNLOAD_METHOD=direct but auth_method=$auth_method for $file_name"
        fi
    else
        # api モードの場合は従来通りチェック
        api_status=$(check_api_rate_limit)
    fi
    # --- APIレート制限情報の取得ここまで ---

    # バージョン比較とダウンロード判断 (変更なし)
    local update_required=false

    if [ "$local_version" = "$dummy_version" ]; then
        debug_log "DEBUG" "First download: $file_name"
        update_required=true
    elif [ "$clean_remote_version" = "$clean_local_version" ]; then
        debug_log "DEBUG" "Exact match: No update needed for $file_name"
        update_required=false
    else
        debug_log "DEBUG" "Starting version comparison: $file_name"
        version_is_newer "$clean_remote_version" "$clean_local_version"
        if [ $? -eq 0 ]; then
            debug_log "DEBUG" "New version detected: Update required for $file_name"
            update_required=true
        else
            debug_log "DEBUG" "Existing version: No update needed for $file_name"
            update_required=false
        fi
    fi

    debug_log "DEBUG" "Remote version: $file_name - $clean_remote_version"
    debug_log "DEBUG" "Local version: $file_name - $clean_local_version"
    # ログに auth_method を追加して、get_commit_version の動作を確認しやすくする
    debug_log "DEBUG" "API status: $api_status (Auth method from get_commit_version: $auth_method)"

    # 結果を返す
    echo "${update_required}|${clean_remote_version}|${clean_local_version}|${api_status}"
    return 0
}

download_fetch_file() {
    local file_name="$1"
    local clean_remote_version="$2"
    local chmod_mode="$3"
    local install_path="${BASE_DIR}/$file_name"
    local script_file="${CACHE_DIR}/script.ch"
    
    debug_log "DEBUG" "download_fetch_file called for ${file_name}"
    
    # ダウンロードURLの設定
    local remote_url="${BASE_URL}/$file_name"
    
    # キャッシュバスティングの適用
    if [ "$FORCE" = "true" ] || echo "$clean_remote_version" | grep -q "direct"; then
        remote_url="${remote_url}${CACHE_BUST}"
    fi
    
    debug_log "DEBUG" "Downloading from ${remote_url} to ${install_path}"
    
    # IPバージョン設定が初期化されていない場合は設定する
    if [ -z "$WGET_IPV_OPT" ]; then
        setup_wget_options
    fi
    
    # BusyBox wget向けに最適化した明示的なコマンド構文
    if ! wget -q --no-check-certificate ${WGET_IPV_OPT} -O "$install_path" "$remote_url" 2>/dev/null; then
        debug_log "DEBUG" "Download failed: $file_name"
        return 1
    fi
    
    # ファイル検証
    if [ ! -f "$install_path" ]; then
        debug_log "DEBUG" "Downloaded file not found: $file_name"
        return 1
    fi
    
    if [ ! -s "$install_path" ]; then
        debug_log "DEBUG" "Downloaded file is empty: $file_name"
        return 1
    fi
    
    debug_log "DEBUG" "File successfully downloaded to ${install_path}"
    
    # 権限設定
    if [ "$chmod_mode" = "true" ]; then
        chmod +x "$install_path"
        debug_log "DEBUG" "chmod +x applied to $file_name"
    fi
    
    # バージョン情報をキャッシュに保存
    save_version_to_cache "$file_name" "$clean_remote_version" "$script_file"
    
    return 0
}

download_finalize() {
    local file_name="$1"
    local status_message="$2" 
    local clean_remote_version="$3"
    local api_status="$4"
    local load_mode="$5"
    local hidden_mode="$6"
    local status_type="$7"
    local interpreter="${8:-ash}"  # デフォルト値をashに設定
    
    debug_log "DEBUG" "Finalizing download for ${file_name}, status=${status_type}, interpreter=${interpreter}"
    
    # ファイルが実際に存在するか確認
    if [ ! -f "${BASE_DIR}/${file_name}" ]; then
        debug_log "DEBUG" "File not found: ${BASE_DIR}/${file_name}"
        return 1
    fi
    
    # 隠しモードチェック
    if [ "$hidden_mode" = "true" ]; then
        debug_log "DEBUG" "Hidden mode is active, skipping status message"
        # 隠しモードの場合はメッセージを表示しない
    else        
        # ファイル名がDBファイルかどうかをチェック (.db拡張子)
        if echo "$file_name" | grep -q "\.db$"; then
            debug_log "DEBUG" "DB file handling for ${file_name}"
        fi
        
        # ステータスメッセージ表示
        if [ "$status_type" = "success" ]; then
            # 成功時
            if [ "$load_mode" = "true" ]; then
                printf "%s\n" "${status_message} ${file_name} ${clean_remote_version} ${api_status} Loaded"
            else
                printf "%s\n" "${status_message} ${file_name} ${clean_remote_version} ${api_status}"
            fi
        else
            # 更新不要時など
            if [ "$load_mode" = "true" ]; then
                printf "%s\n" "${status_message} ${file_name} ${clean_remote_version} ${api_status} Loaded"
            else
                printf "%s\n" "${status_message} ${file_name} ${clean_remote_version} ${api_status}"
            fi
        fi
    fi
    
    # ファイル読込み処理
    if [ "$load_mode" = "true" ]; then
        debug_log "DEBUG" "Loading file with ${interpreter}: ${BASE_DIR}/${file_name}"
        
        if [ -s "${BASE_DIR}/${file_name}" ]; then
            # インタープリタが存在するか確認
            if [ "$interpreter" != "$INTERPRETER" ]; then
                if ! command -v "$interpreter" > /dev/null 2>&1; then
                    printf "%s\n" "$(color red "Error: Interpreter '${interpreter}' is not installed on this system.")"
                    install_package ${interpreter} yn hidden
                    
                    # インストール後に再度確認
                    if ! command -v "$interpreter" > /dev/null 2>&1; then
                        debug_log "EBUG" "Interpreter still not found after installation attempt: ${interpreter}"
                        return 1
                    else
                        debug_log "DEBUG" "Executing with specified interpreter: ${interpreter}"
                        $interpreter "${BASE_DIR}/${file_name}"
                    fi
                else
                    debug_log "DEBUG" "Executing with specified interpreter: ${interpreter}"
                    $interpreter "${BASE_DIR}/${file_name}"
                fi
            else
                debug_log "DEBUG" "File loaded with source"
                . "${BASE_DIR}/${file_name}"
            fi
        else
            debug_log "DEBUG" "Cannot load empty file: ${file_name}"
            return 1
        fi
    fi
    
    return 0
}

# 🔴　ダウンロード系　ここまで　🔴　-------------------------------------------------------------------------------------------------------------------------------------------

# 🔵　バナー・デバイス情報　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------

# メイン関数 - バナー表示の統合関数
# 引数: 
#   $1 - バナースタイル（省略可）: "unicode", "ascii", "asterisk", "auto"
print_banner() {
    # スタイル指定またはデフォルト「auto」
    BANNER_STYLE="${1:-auto}"
    
    # 自動検出が必要な場合
    if [ "$BANNER_STYLE" = "auto" ]; then
        BANNER_STYLE=$(detect_terminal_capability)
        debug_log "DEBUG" "Auto-detected banner style: $BANNER_STYLE"
    fi

    # スタイルに応じたバナー表示
    case "$BANNER_STYLE" in
        unicode|block)
            print_banner_unicode
            ;;
        ascii|hash|sharp)
            print_banner_ascii
            ;;
        *)
            # 不明なスタイルの場合はASCIIにフォールバック
            debug_log "DEBUG" "Unknown banner style: $BANNER_STYLE, using ASCII fallback"
            print_banner_ascii
            ;;
    esac
}

print_banner_ascii() {
    debug_log "DEBUG" "Displaying lowercase aios block ASCII art banner"
    
    # ASCIIアート
    printf "\n"
    printf "%s\n" "$(color magenta "               ## #")"
    printf "%s\n" "$(color blue    "     ####      ###       ####      #####")"
    printf "%s\n" "$(color green   "        ##      ##      ##  ##    ##")"
    printf "%s\n" "$(color yellow  "     #####      ##      ##  ##     #####")"
    printf "%s\n" "$(color orange  "    ##  ##      ##      ##  ##         ##")"
    printf "%s\n" "$(color red     "     #####     ####      ####     ######")"
    printf "\n"
    
    # バナーメッセージ
    printf "%s\n" "$(color white "$(get_message "MSG_BANNER_DECCRIPTION")")"
    printf "%s\n" "$(color white "$(get_message "MSG_BANNER_NAME")")"
    printf "%s\n" "$(color red "$(get_message "MSG_BANNER_DISCLAIMER")")"
    printf "\n"

    debug_log "DEBUG" "Block style lowercase aios banner displayed successfully"
}

print_banner_unicode() {
    debug_log "DEBUG" "Displaying lowercase aios block ASCII art banner"
    
    # ASCIIアート（環境依存文字 - ブロック）
    printf "\n"
    printf "%s\n" "$(color magenta "               ██ █")"
    printf "%s\n" "$(color blue    "     ████      ███       ████      █████")"
    printf "%s\n" "$(color green   "        ██      ██      ██  ██    ██")"
    printf "%s\n" "$(color yellow  "     █████      ██      ██  ██     █████")"
    printf "%s\n" "$(color orange  "    ██  ██      ██      ██  ██         ██")"
    printf "%s\n" "$(color red     "     █████     ████      ████     ██████")"
    printf "\n"

    # バナーメッセージ
    printf "%s\n" "$(color white "$(get_message "MSG_BANNER_DECCRIPTION")")"
    printf "%s\n" "$(color white "$(get_message "MSG_BANNER_NAME")")"
    printf "%s\n" "$(color red "$(get_message "MSG_BANNER_DISCLAIMER")")"
    printf "\n"

    debug_log "DEBUG" "Block style lowercase aios banner displayed successfully"
}

print_information() {
    local cpucore=$(cat "${CACHE_DIR}/cpu_core.ch")
    local network=$(cat "${CACHE_DIR}/network.ch")
    local architecture=$(cat "${CACHE_DIR}/architecture.ch")
    local osversion=$(cat "${CACHE_DIR}/osversion.ch")
    local package_manager=$(cat "${CACHE_DIR}/package_manager.ch")
    local usbdevice=$(cat "${CACHE_DIR}/usbdevice.ch")

    # ファイルが存在しない場合のみメッセージを表示
    if [ ! -f "${CACHE_DIR}/message.ch" ]; then
        printf "%s\n" "$(color green "$(get_message "MSG_INFO_DEVICE")")"
    fi
    printf "%s\n" "$(color white "$(get_message "MSG_INFO_NETWORK" "i=$network")")"
    printf "%s\n" "$(color white "$(get_message "MSG_INFO_CPUCORE" "i=$cpucore")")"
    printf "%s\n" "$(color white "$(get_message "MSG_INFO_ARCHITECTURE" "i=$architecture")")"
    printf "%s\n" "$(color white "$(get_message "MSG_INFO_OSVERSION" "i=$osversion")")"
    printf "%s\n" "$(color white "$(get_message "MSG_INFO_PACKAGEMANAGER" "i=$package_manager")")"
    printf "%s\n" "$(color white "$(get_message "MSG_INFO_USBDEVICE" "i=$usbdevice")")"
    printf "\n"
}

# 🔴　バナー・デバイス情報　ここまで　🔴　-------------------------------------------------------------------------------------------------------------------------------------------

# 🔵　メイン　ここから　🔵　-------------------------------------------------------------------------------------------------------------------------------------------

check_option() {
    # デフォルト値の設定
    ORIGINAL_ARGS="$@"
    MODE="${MODE:-update}"
    SELECTED_LANGUAGE=""
    DEBUG_MODE="false"
    DEBUG_LEVEL="INFO"
    DRY_RUN="false"
    LOGFILE=""
    FORCE="false"
    RESET="false"
    HELP="false"
    SKIP_DEVICE_DETECTION="false"
    SKIP_IP_DETECTION="false"
    SKIP_ALL_DETECTION="false"
    SKIP_CACHE="false"

    # 言語およびオプション引数の処理
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -h|--h|-help|--help|-\?|--\?)
                HELP="true"
                print_help
                exit 0
                ;;
            -v|--v|-version|--version)
                script_version
                exit 0
                ;;
            -d|--d|-debug|--debug|-d1|--d1)
                DEBUG_MODE="true"
                DEBUG_LEVEL="DEBUG"
                ;;
            -cf|--cf|-common_full|--common_full)
                MODE="full"
                ;;
            -cl|--cl|-ocommon_light|--ocommon_light)
                MODE="light"
                ;;
            -cd|--cd|-common_debug|--common_debug|--common_debug)
                MODE="debug"
                ;;
            -r|--r|-resrt|--resrt)
                MODE="reset"
                RESET="true"
                ;;
            -del|--del|-delete|--delete)
                MODE="delete"
                ;;
            -f|--f|-force|--force)
                FORCE="true"
                ;;
            -dr|--dr|-dry-run|--dry-run)
                DRY_RUN="true"
                ;;
            -l|--l|-logfile|--logfile)
                if [ -n "$2" ] && [ "${2#-}" = "$2" ]; then
                    LOGFILE="$2"
                    shift
                else
                    debug_log "DEBUG" "logfile requires a path argument"
                    exit 1
                fi
                ;;
            -u|--u|-update|--update)
                debug_log "DEBUG" "check_option: aios update"
                MODE="update"
                ;;
            -t|--t|-token|--token)
                setup_github_token
                exit 0
                ;;
            -ta|--ta|-test_api|--test_api)
                MODE="test_api"
                ;;
            -sc|--sc|-skip-cache|--skip-cache)
                SKIP_CACHE_DETECTION="true"
                ;;
            -sd|--sd|-skip-dev|--skip-dev)
                SKIP_DEVICE_DETECTION="true"
                ;;
            -scd|--scd|-skip-cache-device|--skip-cache-device)
                SKIP_CACHE_DEVICE_DETECTION="true"
                ;;
            -si|--si|-skip-ip|--skip-ip)
                SKIP_IP_DETECTION="true"
                ;;
            -sa|--sa|-skip-all|--skip-all)
                SKIP_ALL_DETECTION="true"
                ;;
            -nc|--nc|-no-cache|--no-cache)
                SKIP_CACHE="true"
                debug_log "DEBUG" "Cache disabled by command line option"
                ;;
            -*)
                echo "Warning: Unknown option: $1" >&2
                ;;
            *)
                if [ -z "$SELECTED_LANGUAGE" ]; then
                    SELECTED_LANGUAGE="$1"
                fi
                ;;
        esac
        shift
    done

    # 環境変数設定
    export SELECTED_LANGUAGE DEBUG_MODE DEBUG_LEVEL MODE DRY_RUN LOGFILE FORCE RESET HELP SKIP_CACHE

    # デバッグ情報を出力
    debug_log "DEBUG" "$BIN_FILE: $SCRIPT_VERSION"
    debug_log "DEBUG" "check_option received args: $ORIGINAL_ARGS"
    debug_log "DEBUG" "check_option: MODE=$MODE, SKIP_CACHE=$SKIP_CACHE, SELECTED_LANGUAGE=$SELECTED_LANGUAGE"

    # 設定された言語を `check_common()` に渡す
    check_common "$SELECTED_LANGUAGE" "$MODE"
}

check_common() {
    local lang_code="$SELECTED_LANGUAGE"
    local mode="$MODE"

    debug_log "DEBUG" "check_common: MODE=$MODE"
    debug_log "DEBUG" "check_common: mode=$mode"

    # 言語設定の早期読み込み（追加）
    if [ -f "${CACHE_DIR}/message.ch" ]; then
        debug_log "DEBUG" "Early loading language settings from cache"
        # 初期化フラグを設定して二重初期化を防止
        EARLY_LANG_LOADED=1
    fi

    # モードごとの処理
    case "$mode" in
        reset|return)
            if ! rm -rf "${CACHE_DIR}"; then
                debug_log "DEBUG" "Failed to remove cache directory: ${CACHE_DIR}"
                printf "%s%s%s\n" "$(color yellow "Reset failed: Could not remove cache directory.")"
                return 1
            fi
            # キャッシュディレクトリを再作成
            mkdir -p "${CACHE_DIR}" || {
                debug_log "DEBUG" "Failed to recreate cache directory: ${CACHE_DIR}"
                printf "%s%s%s\n" "$(color yellow "Reset partially failed: Cache removed but could not be recreated.")"
            }
            printf "%s%s%s\n" "$(color yellow "$(get_message "MSG_RESET_COMPLETE")")"
            exit 0
            ;;
        delete)
            if ! rm -rf "${BASE_DIR}"; then
                debug_log "DEBUG" "Failed to remove base directory: ${BASE_DIR}"
                printf "%s%s%s\n" "$(color yellow "Reset failed: Could not remove base directory.")"
                return 1
            fi
            # キャッシュディレクトリを再作成
            mkdir -p "${BASE_DIR}" || {
                debug_log "DEBUG" "Failed to recreate base directory: ${CACHE_DIR}"
                printf "%s%s%s\n" "$(color yellow "Reset partially failed: Base removed but could not be recreated.")"
            }
            printf "%s%s%s\n" "$(color yellow "$(get_message "MSG_DELETE_COMPLETE")")"
            exit 0
            ;;
        debug)
            download "common-system.sh" "hidden" "chmod" "load"
            download "common-information.sh" "hidden" "chmod" "load"
            download "common-color.sh" "hidden" "chmod" "load"
            download "common-country.sh" "hidden" "chmod" "load"
            download "common-menu.sh" "hidden" "chmod" "load"
            download "common-package.sh" "hidden" "chmod" "load"
            download "common-feed-package.sh" "hidden" "chmod" "load"
            download "menu.db" "hidden"
            download "country.db" "hidden"
            download "message_${DEFAULT_LANGUAGE}.db" "hidden"
            download "local-package.db" "hidden"
            download "custom-package.db" "hidden"
            print_banner
            print_information
            select_country "$lang_code"
            install_package update
            selector "$MAIN_MENU" 
            ;;
        full)
            download "common-system.sh" "chmod" "load"
            download "common-information.sh" "chmod" "load"
            download "common-translation.sh" "chmod" "load"
            download "common-color.sh" "chmod" "load"
            download "common-country.sh" "chmod" "load"
            download "common-menu.sh" "chmod" "load"
            download "common-package.sh" "chmod" "load"
            download "common-feed-package.sh" "chmod" "load"
            download "menu.db"
            download "country.db"
            download "message_${DEFAULT_LANGUAGE}.db"
            download "local-package.db"
            download "custom-package.db"
            print_banner
            print_information
            select_country "$lang_code"
            install_package update
            selector "$MAIN_MENU"
            ;;
        update)
            check_update "$ORIGINAL_ARGS"
            ;;
        light)
            ;;
        test_api)
            download "github_api_test.sh" "chmod" "load"
            exit 0
            ;;
        *)
            ;;
    esac
    
    return 0
}

# 実行権限の設定
chmod_aios() {
    if ! chmod +x "$BIN_PATH"; then
        debug_log "DEBUG" "Failed to set execute permission"
        return 1
    fi
    return 0
}

# ディレクトリ削除処理
delete_aios() {
    if ! rm -rf "${BASE_DIR}"; then
        debug_log "DEBUG" "Failed to delete $BASE_DIR"
        return 1
    fi
    return 0
}

# 必要ディレクトリ作成
make_directory() {
    if ! mkdir -p "${BASE_DIR}" "$CACHE_DIR" "$LOG_DIR" "$FEED_DIR" "${CACHE_DIR}/commits"; then
        debug_log "DEBUG" "Failed to create required directories"
        return 1
    fi
    
    # .gitignoreファイルの作成（キャッシュディレクトリの内容をgitで無視する）
    if [ ! -f "${CACHE_DIR}/.gitignore" ]; then
        echo "*" > "${CACHE_DIR}/.gitignore" 2>/dev/null
    fi
    
    return 0
}

# アップデート状態確認
check_update() {
    # デフォルトモードの設定（引数がなくても動作するように）
    local lang_code="$SELECTED_LANGUAGE"
    MODE="${MODE:-update}"
    
    # 全引数を処理
    local all_args="$@"
    local has_args=0
    
    # 引数があるかチェック
    [ $# -gt 0 ] && has_args=1
    
    # アップデート関連オプションのみをフィルタリング
    local filtered_args=""
    
    # 引数がある場合のみ処理
    if [ $has_args -eq 1 ]; then
        while [ $# -gt 0 ]; do
            case "$1" in
                -u|--u|-update|--update)
                    # アップデート関連オプションは除外
                    ;;
                *)
                    # その他のオプションは保持
                    filtered_args="${filtered_args:+$filtered_args }$1"
                    ;;
            esac
            shift
        done
    fi
    
    debug_log "DEBUG" "Original args: $all_args"
    debug_log "DEBUG" "Filtered args: $filtered_args"
    
    # ダウンロード実行
    download "aios" "chmod"
    MODE="full"

    # ファイルが存在する場合のみ移動してexec
    if [ -f "$BASE_DIR/$BIN_FILE" ]; then
        mv -f "$BASE_DIR/$BIN_FILE" "$BIN_PATH"
    fi

    exec "$BIN_PATH" "$lang_code" $filtered_args
}

# 初期化処理のメイン
main() {
    # 実行権限を設定
    if ! chmod_aios; then
        debug_log "DEBUG" "Failed to set execute permission"
        return 1
    fi

    # 必要なディレクトリを作成
    if ! make_directory; then
        debug_log "DEBUG" "Failed to create required directories"
        return 1
    fi

    check_network_connectivity

    setup_wget_options

    check_option "$@"
}

# 🔴　メイン　ここまで　🔴　-------------------------------------------------------------------------------------------------------------------------------------------

# スクリプト実行
main "$@"
 
